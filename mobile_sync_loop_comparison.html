<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ABB 동시 구동 로직 비교</title>
    <style>
        :root {
            color-scheme: dark;
        }
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            font-family: "Segoe UI", Arial, sans-serif;
            background: #0f172a;
            color: #e2e8f0;
        }
        main {
            max-width: 900px;
            margin: 0 auto;
            padding: 28px 18px 40px;
        }
        h1 {
            font-size: 1.65rem;
            margin: 0 0 12px;
            color: #f8fafc;
        }
        p {
            line-height: 1.6;
            margin: 0 0 20px;
            color: #cbd5f5;
        }
        .table-card {
            background: rgba(15, 23, 42, 0.78);
            border: 1px solid #1e293b;
            border-radius: 18px;
            overflow: hidden;
            backdrop-filter: blur(6px);
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        thead th {
            text-align: left;
            padding: 14px 18px;
            font-size: 0.82rem;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            color: #94a3b8;
            background: rgba(15, 23, 42, 0.92);
        }
        tbody td {
            padding: 16px 18px;
            border-bottom: 1px solid #1e293b;
            vertical-align: top;
            line-height: 1.55;
        }
        tbody tr:last-child td {
            border-bottom: none;
        }
        .list {
            margin: 0;
            padding-left: 1.1rem;
        }
        .list li {
            margin-bottom: 6px;
        }
        code {
            background: #1e293b;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.85rem;
            color: #38bdf8;
        }
        .highlight {
            color: #f97316;
            font-weight: 600;
        }
        .callout {
            margin-top: 26px;
            padding: 20px 18px;
            border-radius: 16px;
            background: rgba(15, 23, 42, 0.58);
            border: 1px solid #1e293b;
        }
        .callout h2 {
            margin: 0 0 12px;
            font-size: 1.05rem;
            color: #f1f5f9;
        }
        .callout ol {
            margin: 0;
            padding-left: 1.1rem;
            line-height: 1.6;
            color: #cbd5f5;
        }
        .callout li {
            margin-bottom: 12px;
        }
        footer {
            margin-top: 26px;
            font-size: 0.78rem;
            color: #64748b;
        }
        @media (max-width: 640px) {
            thead {
                display: none;
            }
            table,
            tbody,
            tr,
            td {
                display: block;
                width: 100%;
            }
            tbody tr {
                border-bottom: 1px solid #172136;
            }
            tbody td {
                border-bottom: none;
                padding: 14px 18px;
            }
            tbody td::before {
                content: attr(data-label);
                display: block;
                font-size: 0.75rem;
                font-weight: 600;
                letter-spacing: 0.05em;
                text-transform: uppercase;
                color: #38bdf8;
                margin-bottom: 6px;
            }
        }
    </style>
</head>
<body>
    <main>
        <header>
            <h1>ABB 동시 구동 로직 비교</h1>
            <p>
                2025-11-03 B-Line 백업을 검토한 결과, 현행 동시 구동 로직은
                <span class="highlight">정밀한 탈출 조건이 없는 Busy Loop</span> 구조로 되어 있어
                무한 대기와 CPU 점유가 쉽게 발생합니다. 예를 들어
                <code>Rob2_MainModule.mod</code> 706~714라인에서는
                <code>so_MoveG_PosHold</code>가 1로 바뀌지 않으면 루프를 탈출하지 못합니다.
                아래 표에는 이러한 패턴과, 이벤트 기반으로 전환했을 때의 개선 방향을 비교했습니다.
            </p>
        </header>

        <section class="table-card">
            <table>
                <thead>
                    <tr>
                        <th>항목</th>
                        <th>현행 방식 (동시 구동)</th>
                        <th>권장 개선案 (이벤트 기반)</th>
                        <th>기대 효과</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td data-label="항목"><strong>로봇-갠트리 대기</strong></td>
                        <td data-label="현행 방식">
                            <ul class="list">
                                <li><code>WHILE</code> 루프로 PosHold/거리 조건을 계속 폴링</li>
                                <li class="highlight">탈출 조건·타임아웃 없음 → 무한 대기 위험</li>
                                <li><em>상황 예시 ①</em>: 갠트리가 마그넷에 걸려 <code>so_MoveG_PosHold</code>가 0으로 남으면
                                    <code>Rob2_MainModule.mod</code> 706~714라인의 루프가 끝나지 않아 ROB2가 공중에서 정지,
                                    용접이 중단된 채로 Arc가 켜진 상태 유지.</li>
                                <li><em>상황 예시 ②</em>: 갠트리 리미트 센서가 고장나 <code>so_MoveG_PosHold</code>가 1로 고정되면
                                    Busy Loop가 즉시 빠져나가 ROB1/ROB2가 갠트리 준비 전 이동 → Torch 충돌 위험.</li>
                                <li><em>관찰 포인트:</em> <code>logdata/Syslog</code>에는 경고가 남지 않아 현장에서 원인 파악이 어려움.</li>
                            </ul>
                        </td>
                        <td data-label="권장 개선">
                            <ul class="list">
                                <li><code>WaitUntil</code> + 타임아웃 + <code>WaitTime</code>으로 이벤트 대기</li>
                                <li><code>WaitUntil so_MoveG_PosHold=1\MaxTime:=1;</code>처럼 1초 이내 반응을 기대하고,
                                    실패 시 <code>rErrorMoveHome</code> 호출, 홈 위치로 철수</li>
                                <li><code>ISignalDI</code> 인터럽트 Trap으로 신호 변화 시 즉시 처리</li>
                                <li><em>개선 흐름:</em> <code>CONNECT intHold WITH trapHold;</code> → Trap에서 <code>StopMove; ClearPath; StartMove;</code> →
                                    <code>TPWrite "갠트리 Hold 상태, 점검 요망"</code>으로 작업자 알림 → 재시도/중단 결정</li>
                                <li><em>추가 제안:</em> 타임아웃 발생 시 <code>SO_GantryError</code> DO를 점등해 HMI에서 즉시 인지 가능</li>
                            </ul>
                        </td>
                        <td data-label="기대 효과">
                            CPU 점유 감소, 무한 루프 방지, 모션 재현성 확보
                        </td>
                    </tr>
                    <tr>
                        <td data-label="항목"><strong>SyncMove 제어</strong></td>
                        <td data-label="현행 방식">
                            <ul class="list">
                                <li>SyncMoveOn/Off 후에도 Step마다 Busy Loop로 진행 여부 판단</li>
                                <li>중앙 스케줄러 부재로 태스크 간 시차 발생</li>
                                <li><em>상황 예시 ①</em>: Step 12에서 갠트리가 다음 용접선으로 이동하는 동안
                                    <code>Rob1_MainModule</code>은 <code>WHILE so_MoveG_PosHold=1</code>로 대기하다가
                                    신호가 늦게 떨어지면 ROB1이 허공에서 정지 → 비드 시작점에 번짐 발생.</li>
                                <li><em>상황 예시 ②</em>: Step 28에서는 ROB2가 Busy Loop를 먼저 빠져나가 용접을 시작했지만 갠트리가
                                    아직 다음 위치로 이동 중이어서 헤드가 지그에 부딪힐 뻔함.</li>
                                <li><em>관찰 포인트:</em> <code>nMoveid</code> 카운터가 비정상적으로 커지면 Busy Loop 반복 횟수가 늘어난 증거.</li>
                            </ul>
                        </td>
                        <td data-label="권장 개선">
                            <ul class="list">
                                <li>Task7(갠트리)을 마스터, Task1/2는 <code>WaitSyncTask</code> 기반 단계 진입</li>
                                <li>SyncMove 그룹 타임라인을 명시적으로 관리</li>
                                <li><em>개선 흐름:</em> Task7 → <code>SyncMoveOn</code> → <code>WaitSyncTask Wait{20}</code> 송신,
                                    Task1/2는 동일 <code>Wait{20}</code> 수신 후 <code>MoveJ</code> 실행</li>
                                <li><em>추가 제안:</em> Step별로 <code>WaitSyncTask Wait{60 + stepNo}</code>처럼 고유 ID를 주어 로그 분석 용이</li>
                            </ul>
                        </td>
                        <td data-label="기대 효과">
                            ABB MultiMove 흐름에 가까운 동기화, 경로·타이밍 안정
                        </td>
                    </tr>
                    <tr>
                        <td data-label="항목"><strong>Hold / Stop 처리</strong></td>
                        <td data-label="현행 방식">
                            <ul class="list">
                                <li>StopProc 발생 시 <code>Stop;</code> 없이 루프 지속</li>
                                <li>Hold 해제도 폴링만으로 처리 → 안전성 저하</li>
                                <li><em>상황 예시 ①</em>: HMI에서 비상 StopProc을 누르면 <code>Rob1_MainModule</code> trap이 호출되지만
                                    <code>Stop;</code>이 없어 모션이 계속 진행.</li>
                                <li><em>상황 예시 ②</em>: 유지보수 중 로봇을 hold 했다가 해제하면 Busy Loop가 0.5초마다 확인하여
                                    재시작 타이밍이 들쭉날쭉 → 작업자 혼란.</li>
                                <li><em>관찰 포인트:</em> <code>soLn1StopProc</code> 로그가 남지 않으면 Busy Loop에서 신호를 놓친 사례.</li>
                            </ul>
                        </td>
                        <td data-label="권장 개선">
                            <ul class="list">
                                <li><code>sdi/sdo_T_Rob*_StopProc</code> 인터럽트로 즉시 정지</li>
                                <li><code>StopMove → ClearPath → StartMove</code>로 재초기화 순서 명확화</li>
                                <li><em>개선 흐름:</em> Trap에서 <code>StopMove;</code>, <code>ClearPath;</code>, <code>StartMove;</code>,
                                    <code>TPWrite "StopProc 발생, 홈으로 복귀"</code> → 작업자 확인 후 재시작</li>
                                <li><em>추가 제안:</em> StopProc 타임아웃 3초 후 <code>rErrorMoveHome</code> 호출로 안전 위치 복귀</li>
                            </ul>
                        </td>
                        <td data-label="기대 효과">
                            안전 정지 보장, 재시작 절차 간소화
                        </td>
                    </tr>
                    <tr>
                        <td data-label="항목"><strong>WFS = 0 테스트</strong></td>
                        <td data-label="현행 방식">
                            <ul class="list">
                                <li>정규 용접 데이터에서 WFS=0일 때도 Busy Loop로 대기</li>
                                <li>Swap 데이터와 정규 데이터를 코드에서 구분하기 어려움</li>
                                <li><em>상황 예시 ①</em>: 테스트 모드에서 WFS=0을 입력하면 Arc는 꺼졌지만
                                    루프가 계속 돌아 ArcOff 확인이 늦어짐 → 경로 재진입 시 아크 재점화 실패.</li>
                                <li><em>상황 예시 ②</em>: 운영자가 WFS를 다시 30으로 올렸는데 Busy Loop가 조건을 잡지 못해
                                    재시작까지 5~6초 지연.</li>
                            </ul>
                        </td>
                        <td data-label="권장 개선">
                            <ul class="list">
                                <li><em>SwapWeldData_wfs0</em>처럼 별도 세트로 운영 (이미 백업 존재)</li>
                                <li>이벤트 기반 대기로 ArcOn/Off 시퀀스 검증</li>
                                <li><em>개선 흐름:</em> WFS=0 세트에서 <code>WaitUntil soLn1Weld=0\MaxTime:=3;</code>로
                                    ArcOff 타임아웃 검증 후, 실패 시 경고 메시지</li>
                                <li><em>추가 제안:</em> 3호기 스왑 세트를 1/2호기에 복사해 테스트 모드와 생산 모드를 분리,
                                    로그(<code>logdata/Arc</code>)로 ArcOff 응답 시간 기록</li>
                            </ul>
                        </td>
                        <td data-label="기대 효과">
                            Arc 시퀀스 안전 검증, 타 호기에 확장 시 재사용 용이
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section class="callout">
            <h2>상황별 단계 요약</h2>
            <ol>
                <li><strong>갠트리 Hold 미해제</strong><br>
                    ① 갠트리 충돌로 <code>so_MoveG_PosHold</code>=0 유지 → ② ROB2 Busy Loop가 반복 → ③ Arc가 켜진 채 대기 →
                    ④ 제안: <code>WaitUntil ... \MaxTime</code> + Trap에서 <code>StopMove</code> 후 홈 복귀.</li>
                <li><strong>SyncMove 타이밍 어긋남</strong><br>
                    ① Step 28에서 ROB1 Busy Loop를 먼저 빠져나감 → ② 갠트리가 아직 이동 중이라 Torch가 지그에 근접 →
                    ③ 제안: Task7에서 <code>WaitSyncTask</code> 신호를 배포하고 ROB1/2는 신호 수신 후 이동.</li>
                <li><strong>StopProc 미동작</strong><br>
                    ① 작업자가 HMI StopProc → ② Trap 호출되지만 <code>Stop;</code> 없음 → ③ 로봇이 관성으로 이동 →
                    ④ 제안: Trap에 <code>StopMove → ClearPath → StartMove</code> + 로그 남김.</li>
                <li><strong>WFS = 0 테스트 지연</strong><br>
                    ① 테스트 모드에서 WFS=0 입력 → ② Busy Loop가 ArcOff를 늦게 확인 → ③ 재점화 실패로 작업 중단 →
                    ④ 제안: WFS 0 전용 세트 + <code>WaitUntil soLn1Weld=0\MaxTime:=3;</code>로 타임아웃 검사.</li>
            </ol>
        </section>

        <footer>
            기준 백업: Bline_BACKUP_2025-11-03_2040 · 작성: Codex (OpenAI)
        </footer>
    </main>
</body>
</html>
