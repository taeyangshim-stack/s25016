<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gantry System 2D Visualization & Comprehensive Guide - v1.8.21</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            padding: 2rem;
            background-color: #f0f2f5;
            color: #2c3e50;
        }
        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }
        h1, h2, h3, h4 {
            color: #2c3e50;
            border-bottom: 1px solid #dfe6e9;
            padding-bottom: 0.5rem;
        }

        .tab-container {
            width: 100%;
        }
        .tab-buttons {
            display: flex;
            border-bottom: 2px solid #dfe6e9;
        }
        .tab-button {
            padding: 1rem 1.5rem;
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-size: 1rem;
            font-weight: 600;
            color: #7f8c8d;
            position: relative;
            bottom: -2px;
        }
        .tab-button.active {
            color: #3498db;
            border-bottom: 2px solid #3498db;
        }
        .tab-content {
            display: none;
            padding: 2rem 0;
        }
        .tab-content.active {
            display: block;
        }

        #main-container {
            display: flex;
            gap: 2rem;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
        }
        #visualization-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #fff;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }
        canvas {
            border: 1px solid #bdc3c7;
            background-color: #ecf0f1;
        }
        #controls {
            margin-top: 1.5rem;
            width: 100%;
            max-width: 500px;
        }
        .slider-container { width: 100%; display: flex; align-items: center; gap: 1rem; }
        input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 8px; background: #dfe6e9; border-radius: 5px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: #3498db; cursor: pointer; border-radius: 50%; }
        input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; background: #3498db; cursor: pointer; border-radius: 50%; }
        #angle-label { font-size: 1.2rem; font-weight: bold; color: #2980b9; min-width: 70px; text-align: center; }
        
        #calculation-details {
            background-color: #34495e;
            color: #ecf0f1;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            width: 400px;
            flex-shrink: 0;
        }
        #calculation-details h2 { margin-top: 0; color: #5dade2; border-bottom: 1px solid #4a657a; }
        
        .explanation-section { background: #fff; padding: 2rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); line-height: 1.8; margin-bottom: 2rem; }
        .explanation-section pre { background-color: #ecf0f1; padding: 1rem; border-radius: 5px; color: #2c3e50; }
        pre { font-family: 'SF Mono', 'Menlo', 'Monaco', 'Consolas', monospace; font-size: 0.9rem; line-height: 1.6; white-space: pre-wrap; background: #2c3e50; padding: 1rem; border-radius: 5px; }
        
        table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
        th, td { border: 1px solid #dfe6e9; padding: 0.8rem; text-align: left; }
        th { background-color: #ecf0f1; }
        code { background-color: #ecf0f1; color: #c0392b; padding: 0.2em 0.4em; margin: 0; font-size: 85%; border-radius: 3px; font-family: 'SF Mono', 'Menlo', 'Monaco', 'Consolas', monospace; }
        .flow-image { max-width: 100%; border: 1px solid #dfe6e9; border-radius: 4px; margin-top: 1rem; }
        .alert { padding: 1rem; border-radius: 5px; margin-bottom: 1rem; border: 1px solid transparent; }
        .alert-danger { color: #a94442; background-color: #f2dede; border-color: #ebccd1; }
        .alert-success { color: #3c763d; background-color: #dff0d8; border-color: #d6e9c6; }
    </style>
</head>
<body>
    <div class="container">
        <h1>갠트리 시스템 2D 시각화 및 종합 가이드 - v1.8.21</h1>

        <div class="tab-container">
            <div class="tab-buttons">
                <button class="tab-button active" data-tab="tab-visualization">시각화</button>
                <button class="tab-button" data-tab="tab-results">테스트 결과</button>
                <button class="tab-button" data-tab="tab-rotation-guide">좌표 회전 원리</button>
                <button class="tab-button" data-tab="tab-tcp-guide">TCP 변환 방식</button>
                <button class="tab-button" data-tab="tab-future-plans">향후 계획</button>
                <button class="tab-button" data-tab="tab-history">변경 기록</button>
            </div>

            <div id="tab-visualization" class="tab-content active">
                 <div class="explanation-section alert alert-danger">
                    <h3>현재 발생 문제 및 해결 과제</h3>
                    <h4>오류: `50050: Position outside reach` (ROB_2 joint 3)</h4>
                    <p><strong>상황:</strong> 로봇 2 초기화(`SetRobot2InitialPosition`) 과정에서, '중간 자세'에서 '최종 목표 TCP'로 이동하는 <code>MoveJ</code> 명령 실행 시, 3번 관절이 작동 범위를 벗어난다는 기구학적 오류가 발생합니다.</p>
                    <p><strong>근본 원인:</strong> 로봇 1을 기준으로 설정된 "중간 관절 자세" `[0, -2.58, -11.88, 0, 14.47, 0]`가, 반대편에 대칭으로 설치된 로봇 2에게는 매우 부적합한 시작 자세일 가능성이 높습니다. 이 자세에서 목표점으로 이동하려 할 때 3번 관절이 물리적으로 불가능한 경로로 계산되어 오류가 발생합니다.</p>
                    <h4>해결 방안 논의</h4>
                    <ol>
                        <li><strong>(권장) 로봇 2 전용 중간 자세 탐색:</strong> 로봇 2의 설치 방향과 최종 목표 TCP를 모두 고려하여, 충돌 없고 도달 가능한 새로운 "로봇 2 전용 중간 자세"를 찾아 적용해야 합니다.</li>
                        <li><strong>(임시) 이동 방식 변경:</strong> 현재의 <code>MoveJ</code> (관절 이동) 대신 <code>MoveL</code> (직선 이동)을 사용하면 경로가 달라져 문제가 해결될 수 있으나, 근본적인 해결책은 아닙니다.</li>
                    </ol>
                </div>
                <div id="main-container">
                    <div id="visualization-container">
                        <canvas id="gantryCanvas" width="500" height="500"></canvas>
                        <div id="controls">
                            <div class="slider-container">
                                <label for="angle-slider">R축 각도:</label>
                                <input type="range" id="angle-slider" min="-90" max="90" value="0">
                                <span id="angle-label">0.0°</span>
                            </div>
                        </div>
                    </div>
                    <div id="calculation-details">
                        <h2>실시간 계산 과정</h2>
                        <pre id="calc-output"></pre>
                    </div>
                </div>
            </div>

            <div id="tab-results" class="tab-content">
                <div class="explanation-section">
                    <h2>Mode2 랜덤 타겟 검증 결과 (v1.8.21)</h2>
                    <div class="alert alert-success">
                        <strong>결론: 성공.</strong> 현재의 좌표 계산 로직(<code>UpdateRobot2BaseDynamicWobj</code>)은 갠트리의 복합 이동(X,Y,Z,R 동시 변화) 환경에서도 두 로봇의 TCP 좌표를 플로어 좌표계 기준으로 정확히 일치시키는 것을 확인했습니다.
                    </div>
                    <h4>테스트 개요</h4>
                    <ul>
                        <li><strong>테스트 모드:</strong> <code>TEST_MODE=2</code> (복합 이동 테스트)</li>
                        <li><strong>실행 위치:</strong> <code>config.txt</code>에 정의된 10개의 랜덤 위치</li>
                        <li><strong>로그 파일:</strong> <code>HOME/gantry_mode2_test.txt</code></li>
                        <li><strong>검증 목표:</strong> 모든 위치에서 계산된 로봇1과 로봇2의 TCP 좌표 일치 여부 확인</li>
                    </ul>
                    <h4>테스트 결과 상세 (From Log File)</h4>
                    <p>아래 10개의 목표 플로어 좌표(Target)에 대해 테스트를 진행했으며, 모든 위치에서 로봇1(R1)과 로봇2(R2)의 TCP 좌표가 소수점 오차 내에서 목표와 일치함을 확인했습니다.</p>
                    <table>
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Target Floor Coordinate (X,Y,Z,R)</th>
                                <th>Result R1 TCP (X,Y,Z)</th>
                                <th>Result R2 TCP (X,Y,Z)</th>
                                <th>판정</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td>1</td><td>10500, 4900, 1600, 30.0°</td><td>10500.00, 4900.00, 600.00</td><td>10500.00, 4900.00, 600.00</td><td>✅ 일치</td></tr>
                            <tr><td>2</td><td>12000, 4100, 1300, 75.0°</td><td>12000.00, 4100.00, 300.00</td><td>12000.00, 4100.00, 300.00</td><td>✅ 일치</td></tr>
                            <tr><td>3</td><td>7700, 4500, 1800, -45.0°</td><td>7700.00, 4500.00, 800.00</td><td>7700.00, 4500.00, 800.00</td><td>✅ 일치</td></tr>
                            <tr><td>4</td><td>13500, 3300, 1400, 90.0°</td><td>13500.00, 3300.00, 400.00</td><td>13500.00, 3300.00, 400.00</td><td>✅ 일치</td></tr>
                            <tr><td>5</td><td>10100, 5250, 2000, 0.0°</td><td>10100.00, 5250.00, 1000.00</td><td>10100.00, 5250.00, 1000.00</td><td>✅ 일치</td></tr>
                            <tr><td>6</td><td>12700, 3800, 1200, -60.0°</td><td>12700.00, 3800.01, 200.00</td><td>12700.00, 3800.00, 200.00</td><td>✅ 일치</td></tr>
                            <tr><td>7</td><td>7000, 2300, 1700, 15.0°</td><td>6999.99, 2300.00, 700.00</td><td>7000.00, 2300.00, 700.00</td><td>✅ 일치</td></tr>
                            <tr><td>8</td><td>14500, 4300, 1100, -90.0°</td><td>14500.00, 4300.01, 100.00</td><td>14500.00, 4300.00, 100.00</td><td>✅ 일치</td></tr>
                            <tr><td>9</td><td>10300, 5050, 1900, 45.0°</td><td>10300.00, 5050.00, 900.00</td><td>10300.00, 5050.00, 900.00</td><td>✅ 일치</td></tr>
                            <tr><td>10</td><td>8500, 4800, 1500, -30.0°</td><td>8500.00, 4800.00, 500.00</td><td>8500.00, 4800.00, 500.00</td><td>✅ 일치</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div id="tab-rotation-guide" class="tab-content">
                <div class="explanation-section">
                    <h2>좌표 회전 계산 원리</h2>
                    <p>이 섹션은 R축 각도(θ)가 주어졌을 때, <strong>로봇 1</strong>과 <strong>로봇 2</strong> 베이스의 최종 위치 좌표 <code>(x', y')</code>를 계산하는 과정을 단계별로 설명합니다.</p>
                    <h3>1. 핵심 입력 변수</h3>
                    <table>
                        <thead><tr><th>변수</th><th>값</th><th>설명</th></tr></thead>
                        <tbody>
                            <tr><td><strong>R-Axis Center</strong></td><td><code>(0, 0)</code></td><td>모든 계산의 기준이 되는 원점입니다.</td></tr>
                            <tr><td><strong>Robot 1 Initial Offset</strong> (<code>r1_initial</code>)</td><td><code>(x=0, y=488)</code></td><td>R=0°일 때, R축 중심에서 로봇 1 베이스까지의 상대 위치입니다.</td></tr>
                            <tr><td><strong>Robot 2 Initial Offset</strong> (<code>r2_initial</code>)</td><td><code>(x=0, y=-488)</code></td><td>R=0°일 때, R축 중심에서 로봇 2 베이스까지의 상대 위치입니다.</td></tr>
                            <tr><td><strong>R-axis Angle</strong> (<code>θ</code>)</td><td><code>-90°</code> ~ <code>+90°</code></td><td>사용자가 입력하는 R축의 회전 각도입니다.</td></tr>
                        </tbody>
                    </table>
                    <h3>2. 계산 흐름 (단계별)</h3>
                    <h4>1단계: 각도(Degree)를 라디안(Radian)으로 변환</h4>
                    <p>JavaScript의 삼각함수는 라디안 값을 사용하므로, 먼저 각도(θ)를 라디안으로 변환합니다. <b>공식:</b> <code>angle_rad = θ * (π / 180)</code></p>
                    <h4>2단계: 2D 회전 변환 행렬 (Rotation Matrix)</h4>
                    <p>임의의 점 <code>(x, y)</code>를 원점에 대해 <code>θ</code>만큼 회전시킨 새로운 점 <code>(x', y')</code>을 구하기 위해 다음 회전 행렬을 사용합니다.</p>
                    <pre>[ x' ] = [ cos(θ)  -sin(θ) ] [ x ]
[ y' ]   [ sin(θ)   cos(θ) ] [ y ]</pre>
                    <p>이를 풀어서 쓰면 다음과 같습니다:</p>
                    <ol>
                        <li><code>x' = x * cos(θ) - y * sin(θ)</code></li>
                        <li><code>y' = x * sin(θ) + y * cos(θ)</code></li>
                    </ol>
                    <p>이 페이지의 JavaScript에서는 이 공식이 다음과 같이 코드로 구현되어 있습니다:</p>
                    <pre><code>// 'cos', 'sin'은 angle_rad 값으로 미리 계산됨
// initial = { x: 0, y: 488 } (로봇 1의 경우)
const rotated = {
    x: initial.x * cos - initial.y * sin,
    y: initial.x * sin + initial.y * cos
};</code></pre>
                    <h4>3단계: 로봇 베이스의 최종 좌표 계산</h4>
                    <p>위 공식을 각 로봇의 초기 좌표에 적용합니다.</p>
                    <p><b>로봇 1 최종 좌표:</b> <code>x' = -488 * sin(θ)</code>, <code>y' = 488 * cos(θ)</code></p>
                    <p><b>로봇 2 최종 좌표:</b> <code>x' = 488 * sin(θ)</code>, <code>y' = -488 * cos(θ)</code></p>
                </div>
            </div>

            <div id="tab-tcp-guide" class="tab-content">
                <div class="explanation-section">
                    <h2>로봇 TCP 좌표 변환 방식 비교</h2>
                    <p>두 로봇은 시스템 구성이 다르기 때문에, 자신의 TCP 위치를 플로어 좌표계로 확인하는 방법 또한 근본적으로 다릅니다.</p>
                    <h3>로봇 1: 직접 좌표 확인 (갠트리 설정: ✅)</h3>
                    <p>로봇 1은 갠트리를 외부 축으로 인식하므로, ABB 컨트롤러가 갠트리의 움직임을 포함한 모든 좌표 변환을 <strong>자동으로</strong> 수행합니다. 코드에서는 단일 함수 호출만으로 정확한 플로어 좌표를 얻을 수 있습니다.</p>
                    <pre><code>tcp_in_floor := CRobT(\Tool:=tool0, \WObj:=WobjFloor);</code></pre>
                    <p>컨트롤러는 <code>CRobT</code> 함수가 호출되면 내부적으로 갠트리의 현재 회전 값을 고려하여 `WobjFloor` 기준의 TCP 좌표를 계산해 반환합니다. 수동 계산이 전혀 필요 없습니다.</p>
                    <img src="https://res.cloudinary.com/dmmjpofcc/image/upload/v1767629001/s25016/gegamu79ngfo1gzbb93an8yqw.png" alt="Robot 1 Transformation Flow" class="flow-image">
                    <h3>로봇 2: 간접 좌표 확인 (수동 계산, 갠트리 설정: ❌)</h3>
                    <p>로봇 2는 갠트리와 분리되어 있어 컨트롤러가 갠트리의 움직임을 모릅니다. 따라서, 자신의 절대 위치를 알기 위해 여러 정보를 조합하여 <strong>수동으로 계산</strong>해야 합니다. (`UpdateRobot2BaseDynamicWobj` 프로시저)</p>
                    <ol>
                        <li><strong>갠트리 위치 파악:</strong> 제어 권한이 있는 로봇 1의 관절 값을 읽어 갠트리의 현재 상태(특히 R축 각도)를 가져옵니다.<br><code>gantry_joint := CJointT(\TaskName:="T_ROB1");</code></li>
                        <li><strong>로봇 2 베이스 위치 계산:</strong> 1단계에서 얻은 R축 각도와 기구학적 오프셋(-488mm)을 이용해, 회전된 로봇 2 베이스의 절대 플로어 좌표를 계산합니다.</li>
                        <li><strong>로컬 TCP 좌표 확인:</strong> 자신의 베이스(wobj0)를 기준으로 TCP의 로컬 좌표를 확인합니다.<br><code>robot2_tcp_wobj0 := CRobT(\WObj:=wobj0);</code></li>
                        <li><strong>로컬 TCP 좌표 회전 변환:</strong> 3단계에서 구한 로컬 좌표에 R축 각도를 적용하여 플로어 좌표계 방향으로 정렬합니다.</li>
                        <li><strong>최종 좌표 계산:</strong> **2단계**에서 구한 `베이스의 절대 좌표`와 **4단계**에서 구한 `변환된 TCP 오프셋`을 더하여 최종 플로어 TCP 좌표를 구합니다.</li>
                    </ol>
                    <img src="https://res.cloudinary.com/dmmjpofcc/image/upload/v1767628999/s25016/qd3sf6r712a9fkvq81yj391ty.png" alt="Robot 2 Transformation Flow" class="flow-image">
                </div>
            </div>

            <div id="tab-future-plans" class="tab-content">
                 <div class="explanation-section">
                    <h2>향후 진행 계획 및 논의사항</h2>
                    <div class="alert alert-success">
                        <strong>완료:</strong> 아래 "계획 1"은 v1.8.21에서 테스트 및 검증이 완료되었습니다. 자세한 내용은 "테스트 결과" 탭을 참조하십시오.
                    </div>
                    <h3>계획 1: 복합 이동에서의 순방향 기구학 검증</h3>
                    <p>현재의 좌표 계산 로직(특히 로봇 2의 수동 계산)이 R축 단일 회전뿐만 아니라, 갠트리의 X, Y, Z축 이동이 포함된 복합적인 움직임에서도 두 로봇의 TCP 좌표를 정확히 일치시키는지 검증하는 테스트였습니다.</p>
                    
                    <hr style="margin: 2rem 0;">

                    <h3>과제: 용접 경로 기반 역기구학 구현</h3>
                    <p>다음 목표는 '목표 TCP'를 이용해 갠트리와 로봇을 움직이는 **역기구학(Inverse Kinematics)** 문제입니다. 용접 시스템의 특성을 활용하여 문제를 다음과 같이 구체화합니다.</p>
                    <h4>문제 정의</h4>
                    <ul>
                        <li><strong>입력 (Input):</strong> 용접 `시작점 (P_start)`과 `끝점 (P_end)`의 절대 플로어 좌표.</li>
                        <li><strong>제약 조건:</strong> 로봇 암은 용접 방향에 대해 항상 일정한 자세를 유지합니다.</li>
                        <li><strong>출력 (Output):</strong> `시작점 (P_start)`에 로봇 TCP를 위치시키기 위한 갠트리 좌표 `(Gx, Gy, Gz, Gr)`.</li>
                    </ul>
                    <h4>구현을 위한 2-Step 알고리즘</h4>
                    <ol>
                        <li>
                            <strong>1단계: R축 각도(`Gr`) 계산</strong>
                            <p>두 점(시작/끝)으로 정의되는 용접선의 방향이 곧 갠트리가 회전해야 할 R축 각도가 됩니다. XY 평면에서의 각도는 <code>atan2(P_end.y - P_start.y, P_end.x - P_start.x)</code> 함수로 쉽게 계산할 수 있습니다.</p>
                        </li>
                        <li>
                            <strong>2단계: 갠트리 위치(`Gx, Gy, Gz`) 계산</strong>
                            <p><code>Gr</code>이 상수로 결정되었으므로, 비선형 문제가 단순 선형 문제로 바뀝니다. 아래 관계식을 `Gantry_Center`에 대해 정리하면 갠트리의 목표 위치를 직접 계산할 수 있습니다.</p>
                            <p><code>Target_TCP = Gantry_Center + Rotation(Gr) * (Total_Robot_Offset)</code></p>
                        </li>
                    </ol>
                    <pre>개념도:
[용접 시작/끝점] -> [1. R축 각도(Gr) 계산] -> [2. 갠트리 위치(Gx,Gy,Gz) 계산] -> [최종 갠트리 좌표]</pre>
                </div>
            </div>

            <div id="tab-history" class="tab-content">
                <div class="explanation-section">
                    <h2>변경 기록 (Changelog)</h2>
                    <h3>[1.8.21] - 2026-01-08</h3>
                    <ul>
                        <li><strong>DOCS:</strong> Mode2 랜덤 타겟 검증 테스트(v1.8.21)의 상세 결과를 "테스트 결과" 탭에 추가.</li>
                        <li><strong>DOCS:</strong> "향후 계획" 탭의 '복합 이동 검증' 항목을 완료 상태로 업데이트.</li>
                        <li><strong>DOCS:</strong> 역기구학 논의를 '용접 경로 기반 구현' 계획으로 구체화.</li>
                        <li><strong>FEAT:</strong> 페이지 제목에 최신 버전(v1.8.21) 반영.</li>
                    </ul>
                    <h3>[1.4.0] - 2026-01-08</h3>
                    <ul>
                        <li><strong>FEAT:</strong> '시각화' 탭에 현재 발생 중인 `50050` 오류에 대한 설명과 해결 방안을 담은 경고창 추가.</li>
                    </ul>
                    <h3>[1.3.0] - 2026-01-08</h3>
                    <ul>
                        <li><strong>FEAT:</strong> 페이지 구조를 탭 인터페이스로 전면 개편.</li>
                        <li><strong>FEAT:</strong> '변경 기록' 탭을 추가하고 v1.0.0부터의 이력 정리.</li>
                        <li><strong>DOCS:</strong> 기존 모든 설명 자료를 각 탭으로 통합하여 단일 파일로 관리.</li>
                    </ul>
                    <h3>[1.2.0] - 2026-01-07</h3>
                    <ul>
                        <li><strong>DOCS:</strong> 향후 과제(복합 이동 검증, 역기구학 문제)에 대한 설명 섹션 추가.</li>
                    </ul>
                    <h3>[1.1.0] - 2026-01-06</h3>
                    <ul>
                        <li><strong>DOCS:</strong> 로봇 1과 2의 TCP 좌표 계산 방식 차이를 설명하는 가이드 및 순서도 이미지 추가.</li>
                        <li><strong>DOCS:</strong> 회전 행렬 계산 원리 설명에 실제 JavaScript 코드 예시 추가.</li>
                        <li><strong>FIX:</strong> CSS 스타일을 수정하여 설명 영역의 수식 텍스트가 배경과 겹치는 문제 해결.</li>
                    </ul>
                    <h3>[1.0.0] - 2026-01-05</h3>
                    <ul>
                        <li><strong>FEAT:</strong> 갠트리 시스템의 2D 상면도 시각화 기능 최초 생성.</li>
                        <li><strong>FEAT:</strong> R축 각도 조절 슬라이더 및 실시간 계산 과정 표시 기능 구현.</li>
                        <li><strong>FIX:</strong> 시각화의 초기 좌표계가 X, Y축 뒤바뀌어 표시되던 버그 수정.</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Tab Logic ---
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(button.dataset.tab).classList.add('active');
            });
        });

        // --- Visualization Logic ---
        const canvas = document.getElementById('gantryCanvas');
        const ctx = canvas.getContext('2d');
        const slider = document.getElementById('angle-slider');
        const angleLabel = document.getElementById('angle-label');
        const calcOutput = document.getElementById('calc-output');

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const scale = 0.4;
        const robotBaseOffsetY = 488;

        function drawGrid() {
            ctx.beginPath();
            ctx.strokeStyle = '#dfe4ea';
            for (let x = 0; x <= canvas.width; x += 50) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            for (let y = 0; y <= canvas.height; y += 50) {
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            ctx.stroke();
        }

        function drawAxes() {
            ctx.beginPath();
            ctx.strokeStyle = '#95a5a6';
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            ctx.fillStyle = '#7f8c8d';
            ctx.font = '12px sans-serif';
            ctx.fillText('Floor Y+', centerX + 5, 15);
            ctx.fillText('Floor X+', canvas.width - 50, centerY - 10);
        }

        function drawSystem(angle) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawAxes();

            const angleRad = angle * Math.PI / 180;
            const cos = Math.cos(angleRad);
            const sin = Math.sin(angleRad);

            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
            ctx.fillStyle = '#c0392b';
            ctx.fill();
            ctx.fillText('R-Axis Center', centerX + 10, centerY - 10);

            ctx.beginPath();
            ctx.strokeStyle = '#e67e22';
            ctx.lineWidth = 2;
            ctx.moveTo(centerX - 6, centerY - 6);
            ctx.lineTo(centerX + 6, centerY + 6);
            ctx.moveTo(centerX + 6, centerY - 6);
            ctx.lineTo(centerX - 6, centerY + 6);
            ctx.stroke();
            ctx.fillText('TCP', centerX + 10, centerY + 20);
            ctx.lineWidth = 1;

            const r1_initial = { x: 0, y: robotBaseOffsetY };
            const r1_rotated = { x: r1_initial.x * cos - r1_initial.y * sin, y: r1_initial.x * sin + r1_initial.y * cos };
            const r1_canvas_x = centerX + r1_rotated.x * scale;
            const r1_canvas_y = centerY - r1_rotated.y * scale;

            const r2_initial = { x: 0, y: -robotBaseOffsetY };
            const r2_rotated = { x: r2_initial.x * cos - r2_initial.y * sin, y: r2_initial.x * sin + r2_initial.y * cos };
            const r2_canvas_x = centerX + r2_rotated.x * scale;
            const r2_canvas_y = centerY - r2_rotated.y * scale;

            ctx.beginPath();
            ctx.rect(r1_canvas_x - 15, r1_canvas_y - 15, 30, 30);
            ctx.fillStyle = 'rgba(41, 128, 185, 0.8)';
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = '12px sans-serif';
            ctx.fillText('R1', r1_canvas_x - 7, r1_canvas_y + 5);

            ctx.beginPath();
            ctx.rect(r2_canvas_x - 15, r2_canvas_y - 15, 30, 30);
            ctx.fillStyle = 'rgba(39, 174, 96, 0.8)';
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.fillText('R2', r2_canvas_x - 7, r2_canvas_y + 5);

            ctx.beginPath();
            ctx.strokeStyle = '#2c3e50';
            ctx.setLineDash([5, 5]);
            ctx.moveTo(r1_canvas_x, r1_canvas_y);
            ctx.lineTo(centerX, centerY);
            ctx.moveTo(r2_canvas_x, r2_canvas_y);
            ctx.lineTo(centerX, centerY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            updateCalculationText(angle, cos, sin, r1_initial, r1_rotated, r2_initial, r2_rotated);
        }
        
        function updateCalculationText(angle, cos, sin, r1_i, r1_r, r2_i, r2_r) {
             calcOutput.textContent = `R축 각도 (θ) = ${angle.toFixed(1)}°

Rotation Matrix:
[ cos(θ), -sin(θ) ]  [ ${cos.toFixed(2)}, ${-sin.toFixed(2)} ]
[ sin(θ),  cos(θ) ]  [ ${sin.toFixed(2)},  ${cos.toFixed(2)} ]

--- Robot 1 ---
초기 좌표: [${r1_i.x}, ${r1_i.y}]
계산:
x' = ${r1_i.x}*${cos.toFixed(2)} - ${r1_i.y}*${sin.toFixed(2)}
y' = ${r1_i.x}*${sin.toFixed(2)} + ${r1_i.y}*${cos.toFixed(2)}
결과 좌표: [${r1_r.x.toFixed(1)}, ${r1_r.y.toFixed(1)}]

--- Robot 2 ---
초기 좌표: [${r2_i.x}, ${r2_i.y}]
계산:
x' = ${r2_i.x}*${cos.toFixed(2)} - ${r2_i.y}*${sin.toFixed(2)}
y' = ${r2_i.x}*${sin.toFixed(2)} + ${r2_i.y}*${cos.toFixed(2)}
결과 좌표: [${r2_r.x.toFixed(1)}, ${r2_r.y.toFixed(1)}]`;
        }

        slider.addEventListener('input', () => {
            const angle = parseFloat(slider.value);
            angleLabel.textContent = `${angle.toFixed(1)}°`;
            drawSystem(angle);
        });

        // Initial draw
        drawSystem(parseFloat(slider.value));
    </script>
</body>
</html>