<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gantry System 2D Visualization & Comprehensive Guide - v1.8.57</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            padding: 2rem;
            background-color: #f0f2f5;
            color: #2c3e50;
        }
        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }
        h1, h2, h3, h4 {
            color: #2c3e50;
            border-bottom: 1px solid #dfe6e9;
            padding-bottom: 0.5rem;
        }

        .tab-container {
            width: 100%;
        }
        .tab-buttons {
            display: flex;
            border-bottom: 2px solid #dfe6e9;
        }
        .tab-button {
            padding: 1rem 1.5rem;
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-size: 1rem;
            font-weight: 600;
            color: #7f8c8d;
            position: relative;
            bottom: -2px;
        }
        .tab-button.active {
            color: #3498db;
            border-bottom: 2px solid #3498db;
        }
        .tab-content {
            display: none;
            padding: 2rem 0;
        }
        .tab-content.active {
            display: block;
        }

        #main-container {
            display: flex;
            gap: 2rem;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
        }
        #visualization-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #fff;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }
        canvas {
            border: 1px solid #bdc3c7;
            background-color: #ecf0f1;
        }
        #controls {
            margin-top: 1.5rem;
            width: 100%;
            max-width: 500px;
        }
        .slider-container { width: 100%; display: flex; align-items: center; gap: 1rem; }
        input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 8px; background: #dfe6e9; border-radius: 5px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: #3498db; cursor: pointer; border-radius: 50%; }
        input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; background: #3498db; cursor: pointer; border-radius: 50%; }
        #angle-label { font-size: 1.2rem; font-weight: bold; color: #2980b9; min-width: 70px; text-align: center; }
        
        #calculation-details {
            background-color: #34495e;
            color: #ecf0f1;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            width: 400px;
            flex-shrink: 0;
        }
        #calculation-details h2 { margin-top: 0; color: #5dade2; border-bottom: 1px solid #4a657a; }
        
        .explanation-section { background: #fff; padding: 2rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); line-height: 1.8; margin-bottom: 2rem; }
        .explanation-section pre { background-color: #ecf0f1; padding: 1rem; border-radius: 5px; color: #2c3e50; }
        pre { font-family: 'SF Mono', 'Menlo', 'Monaco', 'Consolas', monospace; font-size: 0.9rem; line-height: 1.6; white-space: pre-wrap; background: #2c3e50; padding: 1rem; border-radius: 5px; }
        
        table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
        th, td { border: 1px solid #dfe6e9; padding: 0.8rem; text-align: left; }
        th { background-color: #ecf0f1; }
        code { background-color: #ecf0f1; color: #c0392b; padding: 0.2em 0.4em; margin: 0; font-size: 85%; border-radius: 3px; font-family: 'SF Mono', 'Menlo', 'Monaco', 'Consolas', monospace; }
        .flow-image { max-width: 100%; border: 1px solid #dfe6e9; border-radius: 4px; margin-top: 1rem; }
        .alert { padding: 1rem; border-radius: 5px; margin-bottom: 1rem; border: 1px solid transparent; }
        .alert-danger { color: #a94442; background-color: #f2dede; border-color: #ebccd1; }
        .alert-success { color: #3c763d; background-color: #dff0d8; border-color: #d6e9c6; }
    </style>
</head>
<body>
    <div class="container">
        <h1>갠트리 시스템 2D 시각화 및 종합 가이드 - v1.8.56</h1>

        <div class="tab-container">
            <div class="tab-buttons">
                <button class="tab-button active" data-tab="tab-visualization">시각화</button>
                <button class="tab-button" data-tab="tab-system">시스템 구성</button>
                <button class="tab-button" data-tab="tab-results">테스트 결과</button>
                <button class="tab-button" data-tab="tab-rotation-guide">좌표 회전 원리</button>
                <button class="tab-button" data-tab="tab-tcp-guide">TCP 변환 방식</button>
                <button class="tab-button" data-tab="tab-code">핵심 코드</button>
                <button class="tab-button" data-tab="tab-future-plans">향후 계획</button>
                <button class="tab-button" data-tab="tab-issues">문제 해결 이력</button>
                <button class="tab-button" data-tab="tab-history">변경 기록</button>
            </div>

            <div id="tab-visualization" class="tab-content active">
                 <div class="explanation-section alert alert-success">
                    <h3>현재 상태 및 주의사항 (v1.8.57)</h3>
                    <p><strong>Mode2 설정 방식:</strong> <code>config.txt</code> 파싱을 제거하고 <code>ConfigModule.mod</code>의 PERS 변수를 사용합니다.</p>
                    <p><strong>오프셋 방향 (v1.8.57):</strong> R1_Y=-100, R2_Y=-100. <code>R2 tcp (Y-) ←─[Gantry]─→ R1 tcp (Y+)</code></p>
                    <p><strong>Y 거리 공식:</strong> <code>Y_distance = 200 × cos(R)</code> - R=0°에서 200mm, R각도에 따라 변동 (fixed-joints 방식 특성)</p>
                    <p><strong>TASK 동기화 (v1.8.57):</strong> <code>mode2_config_ready</code> 플래그로 TASK1→TASK2 PERS 값 전달 타이밍 보장</p>
                    <p><strong>Offset 유지 로직 (v1.8.54):</strong> Robot1 joint angles를 초기 offset 이동 후 저장하고, MoveAbsJ에서 고정된 joints를 사용합니다.</p>
                    <p><strong>모듈 로드 순서:</strong> <code>VersionModule.mod → ConfigModule.mod → MainModule.mod</code></p>
                </div>
                <div id="main-container">
                    <div id="visualization-container">
                        <canvas id="gantryCanvas" width="500" height="500"></canvas>
                        <div id="controls">
                            <div class="slider-container">
                                <label for="angle-slider">R축 각도:</label>
                                <input type="range" id="angle-slider" min="-90" max="90" value="0">
                                <span id="angle-label">0.0°</span>
                            </div>
                        </div>
                    </div>
                    <div id="calculation-details">
                        <h2>실시간 계산 과정</h2>
                        <pre id="calc-output"></pre>
                    </div>
                </div>
            </div>

            <div id="tab-system" class="tab-content">
                <div class="explanation-section">
                    <h2>시스템 구성 (System Architecture)</h2>

                    <h3>1. 하드웨어 구성</h3>
                    <table>
                        <thead><tr><th>구성요소</th><th>사양</th><th>설명</th></tr></thead>
                        <tbody>
                            <tr><td><strong>갠트리 X축 (M1)</strong></td><td>[-9.51, 12.31] m</td><td>주행 방향, X1-X2 동기화</td></tr>
                            <tr><td><strong>갠트리 Y축 (M2)</strong></td><td>[-0.05, 5.35] m</td><td>횡방향 이동</td></tr>
                            <tr><td><strong>갠트리 Z축 (M3)</strong></td><td>[-0.05, 1.05] m</td><td>승강</td></tr>
                            <tr><td><strong>갠트리 R축 (M4)</strong></td><td>[-100, 100] deg</td><td>회전축</td></tr>
                            <tr><td><strong>Robot1</strong></td><td>갠트리 config됨</td><td>ABB 컨트롤러가 갠트리 위치 인식</td></tr>
                            <tr><td><strong>Robot2</strong></td><td>갠트리 config 안됨</td><td>TCP 계산 필요 (수동)</td></tr>
                        </tbody>
                    </table>

                    <h3>2. 소프트웨어 구조</h3>
                    <table>
                        <thead><tr><th>Task</th><th>모듈</th><th>역할</th></tr></thead>
                        <tbody>
                            <tr><td rowspan="3"><strong>TASK1</strong><br>(T_ROB1)</td><td>ConfigModule.mod</td><td>MODE2_* PERS 변수 정의</td></tr>
                            <tr><td>VersionModule.mod</td><td>버전 관리 및 히스토리</td></tr>
                            <tr><td>MainModule.mod</td><td>Robot1 제어, 갠트리 동기화, Robot2 TCP 계산</td></tr>
                            <tr><td><strong>TASK2</strong><br>(T_ROB2)</td><td>Rob2_MainModule.mod</td><td>Robot2 제어, 갠트리 오프셋 모니터링</td></tr>
                            <tr><td><strong>TASK7</strong><br>(T_BG)</td><td>Static.mod</td><td>백그라운드 AO 업데이트</td></tr>
                        </tbody>
                    </table>
                    <p><strong>모듈 로드 순서:</strong> <code>ConfigModule → VersionModule → MainModule</code></p>

                    <h3>3. 좌표계 정의</h3>
                    <table>
                        <thead><tr><th>좌표계</th><th>원점 (mm)</th><th>방향</th><th>용도</th></tr></thead>
                        <tbody>
                            <tr><td><strong>WobjFloor</strong></td><td>[-9500, 5300, 2100]</td><td>X축 180° 회전</td><td>측정 기준 (고정)</td></tr>
                            <tr><td><strong>WobjGantry</strong></td><td>[eax_a, eax_b, eax_c]</td><td>Floor와 평행</td><td>Robot1 TCP 제어 (동적)</td></tr>
                            <tr><td><strong>wobj0</strong></td><td>[0, 0, 0]</td><td>Robot 베이스</td><td>로컬 좌표 기준</td></tr>
                        </tbody>
                    </table>
                    <p><strong>Floor ↔ Physical 변환:</strong></p>
                    <pre>gantry_floor_x := physical_x + 9500
gantry_floor_y := 5300 - physical_y  (Y 반전)
gantry_floor_z := 2100 - physical_z  (Z 반전)</pre>

                    <h3>4. 주요 PERS 변수</h3>
                    <h4>Mode2 설정 (ConfigModule.mod)</h4>
                    <table>
                        <thead><tr><th>변수명</th><th>기본값</th><th>설명</th></tr></thead>
                        <tbody>
                            <tr><td><code>MODE2_TCP_OFFSET_R1_X/Y/Z</code></td><td>[0, 100, 0]</td><td>Robot1 TCP 오프셋 (Floor Y = -100×cos(R))</td></tr>
                            <tr><td><code>MODE2_TCP_OFFSET_R2_X/Y/Z</code></td><td>[0, 100, 0]</td><td>Robot2 TCP 오프셋 (Floor Y = +100×cos(R)) <strong>v1.8.56</strong></td></tr>
                            <tr><td><code>MODE2_NUM_POS</code></td><td>3</td><td>테스트 위치 수 (최대 10)</td></tr>
                            <tr><td><code>MODE2_POS_X/Y/Z/R{10}</code></td><td>배열</td><td>테스트 위치 좌표</td></tr>
                        </tbody>
                    </table>
                    <h4>공유 변수 (MainModule.mod)</h4>
                    <table>
                        <thead><tr><th>변수명</th><th>타입</th><th>설명</th></tr></thead>
                        <tbody>
                            <tr><td><code>shared_gantry_x/y/z/r</code></td><td>num</td><td>갠트리 현재 위치 (TASK간 공유)</td></tr>
                            <tr><td><code>robot1_floor_pos_t1</code></td><td>robtarget</td><td>Robot1 TCP Floor 좌표</td></tr>
                            <tr><td><code>robot2_floor_pos_t1</code></td><td>robtarget</td><td>Robot2 TCP Floor 좌표 (계산)</td></tr>
                            <tr><td><code>robot2_init_complete</code></td><td>bool</td><td>TASK2 초기화 완료 플래그</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div id="tab-results" class="tab-content">
                <div class="explanation-section">
                    <h2>Mode2 복합 위치 검증 결과 (v1.8.56)</h2>
                    <div class="alert alert-success">
                        <strong>v1.8.56 변경:</strong> Robot2 offset 부호를 <code>+100</code>으로 변경하여 두 로봇이 갠트리 중심 반대 방향에 위치합니다. Y 거리 = <code>200 × cos(R)</code>mm.
                    </div>
                    <h4>테스트 개요</h4>
                    <ul>
                        <li><strong>테스트 모드:</strong> <code>TEST_MODE=2</code> (복합 이동 테스트)</li>
                        <li><strong>실행 위치:</strong> <code>ConfigModule.mod</code>의 <code>MODE2_POS_*</code> (기본 3개 위치)</li>
                        <li><strong>로그 파일:</strong> <code>HOME/gantry_mode2_test.txt</code></li>
                        <li><strong>검증 목표:</strong> 오프셋 유지 및 로봇1/로봇2 TCP 계산 일관성 확인</li>
                    </ul>
                    <h4>테스트 결과 상세 (From Log File)</h4>
                    <p>아래는 v1.8.56 예상 결과입니다. R1은 Y -100×cos(R), R2는 Y +100×cos(R) 효과가 적용됩니다. (두 로봇이 갠트리 중심 반대 방향)</p>
                    <table>
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Target Floor Coordinate (X,Y,Z,R)</th>
                                <th>Result R1 TCP (X,Y,Z)</th>
                                <th>Result R2 TCP (X,Y,Z)</th>
                                <th>판정</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td>1</td><td>10700, 4900, 1600, 30.0°</td><td>10749.83, 4813.77, 599.75</td><td>10700.00, 4900.00, 600.00</td><td>✅ 오프셋 반영</td></tr>
                            <tr><td>2</td><td>12100, 4400, 1400, -45.0°</td><td>12029.60, 4329.56, 399.75</td><td>12100.00, 4400.00, 400.00</td><td>✅ 오프셋 반영</td></tr>
                            <tr><td>3</td><td>8000, 4700, 1800, 60.0°</td><td>8086.27, 4650.24, 799.75</td><td>8000.00, 4700.00, 800.00</td><td>✅ 오프셋 반영</td></tr>
                        </tbody>
                    </table>

                    <hr style="margin: 2rem 0;">

                    <h3>테스트 이력 (Test History)</h3>
                    <p>각 버전별 테스트 결과를 누적 기록합니다.</p>
                    <table>
                        <thead>
                            <tr>
                                <th>날짜</th>
                                <th>버전</th>
                                <th>테스트 조건</th>
                                <th>위치 수</th>
                                <th>결과</th>
                                <th>비고</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>2026-01-12</td>
                                <td>v1.8.56</td>
                                <td>R2 offset +100 (반대 방향)</td>
                                <td>3</td>
                                <td style="color:orange">⏳ 테스트 예정</td>
                                <td>Y거리 = 200×cos(R) 검증 필요</td>
                            </tr>
                            <tr>
                                <td>2026-01-12</td>
                                <td>v1.8.55</td>
                                <td>R2 488mm 제거 시도</td>
                                <td>3</td>
                                <td style="color:red">❌ FAIL</td>
                                <td>Joint Out of Range 발생</td>
                            </tr>
                            <tr>
                                <td>2026-01-10</td>
                                <td>v1.8.54</td>
                                <td>R1 offset [0,100,0], joints 고정</td>
                                <td>3</td>
                                <td style="color:green">✅ PASS</td>
                                <td>Robot1 자세 유지 확인 필요</td>
                            </tr>
                            <tr>
                                <td>2026-01-10</td>
                                <td>v1.8.53</td>
                                <td>R1 offset [0,100,0], extax 갱신</td>
                                <td>3</td>
                                <td style="color:orange">⚠️ PARTIAL</td>
                                <td>offset 유지되나 자세 변경</td>
                            </tr>
                            <tr>
                                <td>2026-01-09</td>
                                <td>v1.8.52</td>
                                <td>PERS 변수 기반</td>
                                <td>3</td>
                                <td style="color:green">✅ PASS</td>
                                <td>ReadStr hang 해결</td>
                            </tr>
                            <tr>
                                <td>2026-01-08</td>
                                <td>v1.8.21</td>
                                <td>랜덤 타겟 검증</td>
                                <td>10</td>
                                <td style="color:green">✅ PASS</td>
                                <td>복합 이동 검증 완료</td>
                            </tr>
                        </tbody>
                    </table>

                    <h4>정확도 통계 (최근 테스트 기준)</h4>
                    <table>
                        <thead><tr><th>항목</th><th>Robot1</th><th>Robot2</th></tr></thead>
                        <tbody>
                            <tr><td>평균 X 오차</td><td>±0.05 mm</td><td>±0.02 mm</td></tr>
                            <tr><td>평균 Y 오차</td><td>±0.08 mm</td><td>±0.03 mm</td></tr>
                            <tr><td>평균 Z 오차</td><td>±0.25 mm</td><td>±0.01 mm</td></tr>
                            <tr><td>최대 오차</td><td>0.30 mm</td><td>0.05 mm</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div id="tab-rotation-guide" class="tab-content">
                <div class="explanation-section">
                    <h2>좌표 회전 계산 원리</h2>
                    <p>이 섹션은 R축 각도(θ)가 주어졌을 때, <strong>로봇 1</strong>과 <strong>로봇 2</strong> 베이스의 최종 위치 좌표 <code>(x', y')</code>를 계산하는 과정을 단계별로 설명합니다.</p>
                    <h3>1. 핵심 입력 변수</h3>
                    <table>
                        <thead><tr><th>변수</th><th>값</th><th>설명</th></tr></thead>
                        <tbody>
                            <tr><td><strong>R-Axis Center</strong></td><td><code>(0, 0)</code></td><td>모든 계산의 기준이 되는 원점입니다.</td></tr>
                            <tr><td><strong>Robot 1 Initial Offset</strong> (<code>r1_initial</code>)</td><td><code>(x=0, y=488)</code></td><td>R=0°일 때, R축 중심에서 로봇 1 베이스까지의 상대 위치입니다.</td></tr>
                            <tr><td><strong>Robot 2 Initial Offset</strong> (<code>r2_initial</code>)</td><td><code>(x=0, y=-488)</code></td><td>R=0°일 때, R축 중심에서 로봇 2 베이스까지의 상대 위치입니다.</td></tr>
                            <tr><td><strong>R-axis Angle</strong> (<code>θ</code>)</td><td><code>-90°</code> ~ <code>+90°</code></td><td>사용자가 입력하는 R축의 회전 각도입니다.</td></tr>
                        </tbody>
                    </table>
                    <h3>2. 계산 흐름 (단계별)</h3>
                    <h4>1단계: 각도(Degree)를 라디안(Radian)으로 변환</h4>
                    <p>JavaScript의 삼각함수는 라디안 값을 사용하므로, 먼저 각도(θ)를 라디안으로 변환합니다. <b>공식:</b> <code>angle_rad = θ * (π / 180)</code></p>
                    <h4>2단계: 2D 회전 변환 행렬 (Rotation Matrix)</h4>
                    <p>임의의 점 <code>(x, y)</code>를 원점에 대해 <code>θ</code>만큼 회전시킨 새로운 점 <code>(x', y')</code>을 구하기 위해 다음 회전 행렬을 사용합니다.</p>
                    <pre>[ x' ] = [ cos(θ)  -sin(θ) ] [ x ]
[ y' ]   [ sin(θ)   cos(θ) ] [ y ]</pre>
                    <p>이를 풀어서 쓰면 다음과 같습니다:</p>
                    <ol>
                        <li><code>x' = x * cos(θ) - y * sin(θ)</code></li>
                        <li><code>y' = x * sin(θ) + y * cos(θ)</code></li>
                    </ol>
                    <p>이 페이지의 JavaScript에서는 이 공식이 다음과 같이 코드로 구현되어 있습니다:</p>
                    <pre><code>// 'cos', 'sin'은 angle_rad 값으로 미리 계산됨
// initial = { x: 0, y: 488 } (로봇 1의 경우)
const rotated = {
    x: initial.x * cos - initial.y * sin,
    y: initial.x * sin + initial.y * cos
};</code></pre>
                    <h4>3단계: 로봇 베이스의 최종 좌표 계산</h4>
                    <p>위 공식을 각 로봇의 초기 좌표에 적용합니다.</p>
                    <p><b>로봇 1 최종 좌표:</b> <code>x' = -488 * sin(θ)</code>, <code>y' = 488 * cos(θ)</code></p>
                    <p><b>로봇 2 최종 좌표:</b> <code>x' = 488 * sin(θ)</code>, <code>y' = -488 * cos(θ)</code></p>
                </div>
            </div>

            <div id="tab-tcp-guide" class="tab-content">
                <div class="explanation-section">
                    <h2>로봇 TCP 좌표 변환 방식 비교</h2>
                    <p>두 로봇은 시스템 구성이 다르기 때문에, 자신의 TCP 위치를 플로어 좌표계로 확인하는 방법 또한 근본적으로 다릅니다.</p>

                    <h3>시스템 구성 개요도 (v1.8.57)</h3>
                    <div style="background: #1a252f; color: #ecf0f1; padding: 1.5rem; border-radius: 8px; font-family: 'SF Mono', monospace; font-size: 0.85rem; overflow-x: auto; margin-bottom: 2rem;">
<pre style="margin: 0; background: transparent; padding: 0;">
┌─────────────────────────────────────────────────────────────────────────────┐
│  <span style="color: #3498db; font-weight: bold;">Robot1 (갠트리 config됨)</span> - TASK1                                         │
│                                                                             │
│  ┌──────────────────┐                                                       │
│  │ <span style="color: #f39c12;">CRobT()</span>          │                                                       │
│  │ \Tool:=tool0     │ ──────▶ <span style="color: #2ecc71; font-weight: bold;">Floor TCP (컨트롤러 자동 계산)</span>                │
│  │ \WObj:=WobjFloor │         갠트리 위치 + 로봇 관절 → 통합 변환            │
│  └──────────────────┘                                                       │
│                                                                             │
│  <span style="color: #95a5a6;">※ 추가 수동 계산 불필요</span>                                                   │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  <span style="color: #e74c3c; font-weight: bold;">Robot2 (갠트리 config 안됨)</span> - TASK1에서 계산                              │
│                                                                             │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐                   │
│  │ <span style="color: #f39c12;">CJointT()</span>    │    │ <span style="color: #f39c12;">CRobT()</span>      │    │ <span style="color: #9b59b6;">수동 회전</span>    │                   │
│  │ TASK1에서    │ +  │ \TaskName:=  │ +  │ <span style="color: #9b59b6;">변환 행렬</span>    │                   │
│  │ 갠트리 위치  │    │ "T_ROB2"     │    │ <span style="color: #9b59b6;">적용</span>         │                   │
│  │ 읽기         │    │ \WObj:=wobj0 │    │              │                   │
│  └──────────────┘    └──────────────┘    └──────────────┘                   │
│         │                   │                   │                           │
│         ▼                   ▼                   ▼                           │
│    <span style="color: #1abc9c;">갠트리 Floor</span>       <span style="color: #1abc9c;">Robot2 TCP</span>        <span style="color: #1abc9c;">회전 변환</span>                        │
│    <span style="color: #1abc9c;">+ R축 회전</span>        <span style="color: #1abc9c;">(wobj0 기준)</span>       <span style="color: #1abc9c;">적용</span>                             │
│         │                   │                   │                           │
│         └───────────────────┴───────────────────┘                           │
│                             │                                               │
│                             ▼                                               │
│                    <span style="color: #2ecc71; font-weight: bold;">robot2_floor_pos_t1</span>                                       │
│                    <span style="color: #2ecc71;">(Floor 기준 TCP)</span>                                         │
└─────────────────────────────────────────────────────────────────────────────┘
</pre>
                    </div>

                    <h3>로봇 1: 직접 좌표 확인 (갠트리 설정: ✅)</h3>
                    <p>로봇 1은 갠트리를 외부 축으로 인식하므로, ABB 컨트롤러가 갠트리의 움직임을 포함한 모든 좌표 변환을 <strong>자동으로</strong> 수행합니다. 코드에서는 단일 함수 호출만으로 정확한 플로어 좌표를 얻을 수 있습니다.</p>
                    <pre><code>! MainModule.mod Line 1261
robot1_floor_pos_t1 := CRobT(\Tool:=tool0\WObj:=WobjFloor);</code></pre>
                    <p>컨트롤러는 <code>CRobT</code> 함수가 호출되면 내부적으로 갠트리의 현재 회전 값을 고려하여 `WobjFloor` 기준의 TCP 좌표를 계산해 반환합니다. 수동 계산이 전혀 필요 없습니다.</p>
                    <img src="https://res.cloudinary.com/dmmjpofcc/image/upload/v1767629001/s25016/gegamu79ngfo1gzbb93an8yqw.png" alt="Robot 1 Transformation Flow" class="flow-image">

                    <h3>로봇 2: 간접 좌표 확인 (수동 계산, 갠트리 설정: ❌)</h3>
                    <p>로봇 2는 갠트리와 분리되어 있어 컨트롤러가 갠트리의 움직임을 모릅니다. 따라서, 자신의 절대 위치를 알기 위해 여러 정보를 조합하여 <strong>수동으로 계산</strong>해야 합니다. (`UpdateRobot2BaseDynamicWobj` 프로시저)</p>

                    <h4>Robot2 Floor TCP 계산 6단계 (MainModule.mod Line 1325-1434)</h4>
                    <ol>
                        <li><strong>갠트리 위치 파악:</strong> 제어 권한이 있는 로봇 1의 관절 값을 읽어 갠트리의 현재 상태(특히 R축 각도)를 가져옵니다.
                            <pre><code>current_gantry := CJointT();
r_deg := current_gantry.extax.eax_d;</code></pre>
                        </li>
                        <li><strong>갠트리 Floor 좌표 계산:</strong> 물리적 갠트리 좌표를 Floor 좌표계로 변환합니다.
                            <pre><code>gantry_floor_x := current_gantry.extax.eax_a + 9500;
gantry_floor_y := 5300 - current_gantry.extax.eax_b;
gantry_floor_z := 2100 - current_gantry.extax.eax_c;</code></pre>
                        </li>
                        <li><strong>로봇 2 베이스 위치 계산:</strong> R축 각도와 기구학적 오프셋(-488mm)을 이용해, 회전된 로봇 2 베이스의 절대 플로어 좌표를 계산합니다.
                            <pre><code>base_floor_x := gantry_floor_x + (488 * Sin(total_r_deg));
base_floor_y := gantry_floor_y - (488 * Cos(total_r_deg));
base_floor_z := gantry_floor_z;</code></pre>
                        </li>
                        <li><strong>로컬 TCP 좌표 확인:</strong> 자신의 베이스(wobj0)를 기준으로 TCP의 로컬 좌표를 확인합니다 (<span style="color: #e74c3c;">로봇 컨트롤러 기본 기능 사용</span>).
                            <pre><code>robot2_tcp_wobj0 := CRobT(\TaskName:="T_ROB2"\Tool:=tool0\WObj:=wobj0);</code></pre>
                        </li>
                        <li><strong>로컬 TCP 좌표 회전 변환:</strong> 4단계에서 구한 로컬 좌표에 R축 각도를 적용하여 플로어 좌표계 방향으로 정렬합니다.
                            <pre><code>! 회전 변환 행렬: [cos(R) -sin(R); sin(R) cos(R)]
floor_x_offset := robot2_tcp_wobj0.trans.x * Cos(total_r_deg)
                - robot2_tcp_wobj0.trans.y * Sin(total_r_deg);
floor_y_offset := robot2_tcp_wobj0.trans.x * Sin(total_r_deg)
                + robot2_tcp_wobj0.trans.y * Cos(total_r_deg);
floor_z_offset := robot2_tcp_wobj0.trans.z;</code></pre>
                        </li>
                        <li><strong>최종 좌표 계산:</strong> 3단계에서 구한 <code>베이스의 절대 좌표</code>와 5단계에서 구한 <code>변환된 TCP 오프셋</code>을 더하여 최종 플로어 TCP 좌표를 구합니다.
                            <pre><code>robot2_floor_pos_t1.trans.x := base_floor_x + floor_x_offset;
robot2_floor_pos_t1.trans.y := base_floor_y + floor_y_offset;
robot2_floor_pos_t1.trans.z := base_floor_z + floor_z_offset;</code></pre>
                        </li>
                    </ol>
                    <img src="https://res.cloudinary.com/dmmjpofcc/image/upload/v1767628999/s25016/qd3sf6r712a9fkvq81yj391ty.png" alt="Robot 2 Transformation Flow" class="flow-image">

                    <h3>Y 거리 계산 원리 (v1.8.57)</h3>
                    <div style="background: #ecf0f1; padding: 1.5rem; border-radius: 8px; margin-top: 1rem;">
                        <p><strong>TCP Y 거리 = 200 × cos(R)</strong></p>
                        <ul>
                            <li><strong>Robot1</strong>: 갠트리 config → 컨트롤러가 <code>WobjGantry + 로봇 관절</code>을 통합 계산</li>
                            <li><strong>Robot2</strong>: TASK1에서 <code>갠트리 위치 + wobj0 TCP + 회전 변환</code> 조합</li>
                            <li>R=0°: 거리 = 200mm, R=30°: 거리 = 173mm, R=60°: 거리 = 100mm</li>
                        </ul>
                        <p style="margin-top: 1rem;"><strong>v1.8.57 오프셋 방향:</strong></p>
                        <pre style="background: #2c3e50; color: #ecf0f1;">R2 tcp (Y-) ←──[Gantry R-center]──→ R1 tcp (Y+)
                 │                │
        Robot2: R2_Y=-100    Robot1: R1_Y=-100
        offset_tcp.Y=388     WobjGantry.Y=-100
        Floor: -100×cos(R)   Floor: +100×cos(R)</pre>
                    </div>
                </div>
            </div>

            <div id="tab-code" class="tab-content">
                <div class="explanation-section">
                    <h2>핵심 RAPID 코드 스니펫</h2>
                    <p>이 섹션은 갠트리 시스템의 핵심 RAPID 코드를 정리합니다. 팀원 교육 및 디버깅 참조용입니다.</p>

                    <h3>1. Robot1 TCP 계산 (직접 - 갠트리 config됨)</h3>
                    <pre><code>! Robot1은 갠트리를 외부축으로 인식하므로 단일 호출로 Floor 좌표 획득
PROC UpdateRobot1FloorPosition()
    robot1_floor_pos_t1 := CRobT(\Tool:=tool0, \WObj:=WobjFloor);
ENDPROC</code></pre>

                    <h3>2. Robot2 TCP 계산 (수동 - 갠트리 config 안됨)</h3>
                    <pre><code>PROC UpdateRobot2BaseDynamicWobj()
    VAR jointtarget gantry_joint;
    VAR num R_deg;
    VAR num gantry_floor_x, gantry_floor_y, gantry_floor_z;
    VAR num base_floor_x, base_floor_y, base_floor_z;
    VAR robtarget robot2_tcp_wobj0;
    VAR num floor_x_offset, floor_y_offset, floor_z_offset;

    ! Step 1: R축 각도 읽기
    gantry_joint := CJointT(\TaskName:="T_ROB1");
    R_deg := -gantry_joint.extax.eax_d;  ! 부호 반전

    ! Step 2: 갠트리 Floor 좌표 계산
    gantry_floor_x := gantry_joint.extax.eax_a + 9500;
    gantry_floor_y := 5300 - gantry_joint.extax.eax_b;
    gantry_floor_z := 2100 - gantry_joint.extax.eax_c;

    ! Step 3: Robot2 베이스 위치 계산 (R축 회전 적용)
    base_floor_x := gantry_floor_x + 488 * Sin(R_deg);
    base_floor_y := gantry_floor_y - 488 * Cos(R_deg);
    base_floor_z := gantry_floor_z;

    ! Step 4: Robot2 로컬 TCP 읽기
    robot2_tcp_wobj0 := CRobT(\TaskName:="T_ROB2"\Tool:=tool0\WObj:=wobj0);

    ! Step 5: 로컬 TCP에 회전 변환 적용
    floor_x_offset := robot2_tcp_wobj0.trans.x * Cos(R_deg)
                    - robot2_tcp_wobj0.trans.y * Sin(R_deg);
    floor_y_offset := robot2_tcp_wobj0.trans.x * Sin(R_deg)
                    + robot2_tcp_wobj0.trans.y * Cos(R_deg);
    floor_z_offset := robot2_tcp_wobj0.trans.z;

    ! Step 6: 최종 Floor 좌표 계산
    robot2_floor_pos_t1.trans.x := base_floor_x + floor_x_offset;
    robot2_floor_pos_t1.trans.y := base_floor_y + floor_y_offset;
    robot2_floor_pos_t1.trans.z := base_floor_z + floor_z_offset;
ENDPROC</code></pre>

                    <h3>3. WobjGantry 업데이트</h3>
                    <pre><code>PROC UpdateGantryWobj()
    VAR jointtarget gantry_pos;
    gantry_pos := CJointT();

    ! 갠트리 현재 위치로 WobjGantry 원점 업데이트
    WobjGantry.oframe.trans.x := gantry_pos.extax.eax_a;
    WobjGantry.oframe.trans.y := gantry_pos.extax.eax_b;
    WobjGantry.oframe.trans.z := gantry_pos.extax.eax_c;

    ! R축 회전은 반영하지 않음 (Floor와 평행 유지)
ENDPROC</code></pre>

                    <h3>4. Mode2 테스트 핵심 로직 (v1.8.54)</h3>
                    <pre><code>! 초기 offset 이동 후 Robot1 joint angles 저장
MoveJ offset_tcp, v100, fine, tool0\WObj:=WobjGantry;
current_gantry := CJointT();
robot1_offset_joints := current_gantry.robax;  ! joints 저장

! FOR 루프 내: 저장된 joints로 MoveAbsJ 실행
FOR i FROM 1 TO num_pos DO
    test_pos := CJointT();
    test_pos.robax := robot1_offset_joints;  ! Robot1 joints 고정!
    test_pos.extax.eax_a := phys_x;
    test_pos.extax.eax_b := phys_y;
    test_pos.extax.eax_c := phys_z;
    test_pos.extax.eax_d := phys_r;
    test_pos.extax.eax_f := test_pos.extax.eax_a;
    MoveAbsJ test_pos, v100, fine, tool0;  ! 갠트리만 이동, Robot1 자세 유지

    ! 측정
    UpdateRobot1FloorPosition;
    UpdateRobot2BaseDynamicWobj;
ENDFOR</code></pre>

                    <h3>5. 주요 프로시저 호출 관계</h3>
                    <pre>main()
├── SetRobot1InitialPosition()
│   ├── UpdateGantryWobj()
│   └── MoveAbsJ (X1-X2 동기화)
│
├── TestGantryMode2()
│   ├── ConfigModule.mod에서 MODE2_* 읽기
│   ├── robot1_offset_joints 저장
│   └── FOR loop:
│       ├── test_pos.robax := robot1_offset_joints
│       ├── MoveAbsJ (갠트리만 이동)
│       ├── UpdateRobot1FloorPosition()
│       └── UpdateRobot2BaseDynamicWobj()
│
└── 로그 파일 출력
    ├── gantry_mode2_test.txt (CSV)
    └── tp_messages.txt (상세)</pre>
                </div>
            </div>

            <div id="tab-future-plans" class="tab-content">
                 <div class="explanation-section">
                    <h2>향후 진행 계획 및 논의사항</h2>
                    <div class="alert alert-success">
                        <strong>완료:</strong> Mode2 복합 이동 검증은 v1.8.53 기준으로 정상 실행 및 로그 기록이 확인되었습니다.
                    </div>
                    <h3>계획 1: 복합 이동에서의 순방향 기구학 검증</h3>
                    <p>좌표 계산 로직(특히 로봇 2의 수동 계산)이 갠트리의 X, Y, Z, R 복합 이동에서도 안정적으로 동작하는지 확인했습니다. 현재는 PERS 설정 기반으로 안정화되었습니다.</p>
                    
                    <hr style="margin: 2rem 0;">

                    <h3>과제: 용접 경로 기반 역기구학 구현</h3>
                    <p>다음 목표는 '목표 TCP'를 이용해 갠트리와 로봇을 움직이는 **역기구학(Inverse Kinematics)** 문제입니다. 용접 시스템의 특성을 활용하여 문제를 다음과 같이 구체화합니다.</p>
                    <h4>문제 정의</h4>
                    <ul>
                        <li><strong>입력 (Input):</strong> 용접 `시작점 (P_start)`과 `끝점 (P_end)`의 절대 플로어 좌표.</li>
                        <li><strong>제약 조건:</strong> 로봇 암은 용접 방향에 대해 항상 일정한 자세를 유지합니다.</li>
                        <li><strong>출력 (Output):</strong> `시작점 (P_start)`에 로봇 TCP를 위치시키기 위한 갠트리 좌표 `(Gx, Gy, Gz, Gr)`.</li>
                    </ul>
                    <h4>구현을 위한 2-Step 알고리즘</h4>
                    <ol>
                        <li>
                            <strong>1단계: R축 각도(`Gr`) 계산</strong>
                            <p>두 점(시작/끝)으로 정의되는 용접선의 방향이 곧 갠트리가 회전해야 할 R축 각도가 됩니다. XY 평면에서의 각도는 <code>atan2(P_end.y - P_start.y, P_end.x - P_start.x)</code> 함수로 쉽게 계산할 수 있습니다.</p>
                        </li>
                        <li>
                            <strong>2단계: 갠트리 위치(`Gx, Gy, Gz`) 계산</strong>
                            <p><code>Gr</code>이 상수로 결정되었으므로, 비선형 문제가 단순 선형 문제로 바뀝니다. 아래 관계식을 `Gantry_Center`에 대해 정리하면 갠트리의 목표 위치를 직접 계산할 수 있습니다.</p>
                            <p><code>Target_TCP = Gantry_Center + Rotation(Gr) * (Total_Robot_Offset)</code></p>
                        </li>
                    </ol>
                    <pre>개념도:
[용접 시작/끝점] -> [1. R축 각도(Gr) 계산] -> [2. 갠트리 위치(Gx,Gy,Gz) 계산] -> [최종 갠트리 좌표]</pre>
                </div>
            </div>

            <div id="tab-issues" class="tab-content">
                <div class="explanation-section">
                    <h2>문제 해결 이력 (Troubleshooting Log)</h2>
                    <p>개발 중 발생한 주요 문제와 해결 방법을 기록합니다. 유사 이슈 발생 시 참조하세요.</p>

                    <h3>주요 이슈 해결 테이블</h3>
                    <table>
                        <thead>
                            <tr>
                                <th style="width:80px">버전</th>
                                <th style="width:100px">날짜</th>
                                <th>문제</th>
                                <th>원인 분석</th>
                                <th>해결 방법</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr style="background:#d5f5e3">
                                <td><code>v1.8.56</code></td>
                                <td>2026-01-12</td>
                                <td>TCP 거리가 R각도에 따라 100~173mm로 변동 (목표 200mm)</td>
                                <td>Robot1/Robot2 offset이 같은 Y 방향으로 적용됨. Floor Y effect = (488+offset-488)×cos(R)</td>
                                <td>Robot2 <code>tcp_offset_y</code>를 <code>-100 → +100</code>으로 변경. Y거리 = 200×cos(R)</td>
                            </tr>
                            <tr style="background:#fdebd0">
                                <td><code>v1.8.55</code></td>
                                <td>2026-01-12</td>
                                <td>Robot2 488mm 제거 시 Joint Out of Range 발생</td>
                                <td>Robot2 도달 범위 초과 (WobjGantry_Rob2 기준 -100mm는 너무 멀음)</td>
                                <td>488mm 유지, offset 부호 변경으로 해결 (v1.8.56)</td>
                            </tr>
                            <tr style="background:#d5f5e3">
                                <td><code>v1.8.54</code></td>
                                <td>2026-01-10</td>
                                <td>Robot1 TCP 방향이 갠트리 위치마다 변경됨</td>
                                <td>MoveJ가 매번 역운동학으로 다른 joint angles 계산</td>
                                <td><code>robot1_offset_joints</code> 저장 후 MoveAbsJ에서 고정 사용, 루프 내 MoveJ 제거</td>
                            </tr>
                            <tr style="background:#d5f5e3">
                                <td><code>v1.8.53</code></td>
                                <td>2026-01-10</td>
                                <td>Robot1 TCP가 offset 위치 유지 안 함</td>
                                <td>MoveAbsJ 후 extax 값이 stale (eax_e 불일치)</td>
                                <td>MoveAbsJ 후 <code>current_gantry := CJointT()</code>로 extax 갱신</td>
                            </tr>
                            <tr style="background:#d5f5e3">
                                <td><code>v1.8.51</code></td>
                                <td>2026-01-09</td>
                                <td>ReadStr에서 hang (두 번째 ReadStr)</td>
                                <td>config.txt 파일 파싱 중 I/O 블로킹</td>
                                <td>파일 파싱 제거, PERS 변수로 마이그레이션 (ConfigModule.mod)</td>
                            </tr>
                            <tr style="background:#d5f5e3">
                                <td><code>v1.8.2</code></td>
                                <td>2026-01-03</td>
                                <td>Robot2 TCP 976mm 오차 (R=90°)</td>
                                <td>Robot2 로컬 TCP에 R축 회전 변환 누락</td>
                                <td>회전 행렬 적용: <code>floor_x := wobj0_x*Cos(R) - wobj0_y*Sin(R)</code></td>
                            </tr>
                            <tr style="background:#d5f5e3">
                                <td><code>v1.8.0</code></td>
                                <td>2026-01-03</td>
                                <td>단일 위치만 테스트 가능</td>
                                <td>하드코딩된 테스트 좌표</td>
                                <td>TEST_MODE 도입 (0-3), 복수 위치 지원</td>
                            </tr>
                            <tr style="background:#fdebd0">
                                <td><code>v1.4.0</code></td>
                                <td>2026-01-08</td>
                                <td>50050 In Position Timeout 오류</td>
                                <td>갠트리 축 이동 중 타임아웃</td>
                                <td>X1-X2 점진적 동기화 로직 추가</td>
                            </tr>
                        </tbody>
                    </table>
                    <p><span style="background:#d5f5e3;padding:2px 6px;border-radius:3px">녹색</span>: 해결 완료 | <span style="background:#fdebd0;padding:2px 6px;border-radius:3px">주황색</span>: 주의 필요</p>

                    <h3>디버깅 팁</h3>
                    <ul>
                        <li><strong>TCP 오차 확인:</strong> <code>gantry_mode2_test.txt</code>에서 Target vs Result 비교</li>
                        <li><strong>상세 로그:</strong> <code>tp_messages.txt</code>에서 각 단계별 값 확인</li>
                        <li><strong>joint angles 확인:</strong> <code>CJointT()</code> 반환값의 robax/extax 분리 확인</li>
                        <li><strong>좌표계 혼동 주의:</strong> WobjGantry(동적) vs WobjFloor(고정) vs wobj0(로컬)</li>
                    </ul>
                </div>
            </div>

            <div id="tab-history" class="tab-content">
                <div class="explanation-section">
                    <h2>변경 기록 (Changelog)</h2>
                    <p>상세 변경 내역을 기록합니다. 작업자, 변경 파일, 라인 번호 포함.</p>

                    <div style="background:#f8f9fa; padding:1rem; border-radius:5px; margin-bottom:1.5rem; border-left:4px solid #27ae60;">
                        <h3 style="margin-top:0; border:none;">[1.8.57] - 2026-01-13 06:30</h3>
                        <p><strong>작업자:</strong> Claude/심태양 | <strong>관련 이슈:</strong> 오프셋 방향 반전 + TASK 타이밍 동기화</p>
                        <p><strong>변경 파일:</strong> <code>ConfigModule.mod</code>, <code>MainModule.mod</code>, <code>Rob2_MainModule.mod</code>, <code>VersionModule.mod</code></p>
                        <table style="margin:0.5rem 0;">
                            <thead><tr><th>유형</th><th>내용</th></tr></thead>
                            <tbody>
                                <tr><td style="color:#f39c12">CHANGE</td><td><code>MODE2_TCP_OFFSET_R1_Y := +100</code> → <code>-100</code> (Robot1 위로)</td></tr>
                                <tr><td style="color:#f39c12">CHANGE</td><td><code>MODE2_TCP_OFFSET_R2_Y := +100</code> → <code>-100</code> (Robot2 아래로)</td></tr>
                                <tr><td style="color:#27ae60">ADD</td><td><code>mode2_config_ready</code> PERS bool 동기화 플래그</td></tr>
                                <tr><td style="color:#27ae60">ADD</td><td>TASK2: 플래그 대기 로직 (최대 10초)</td></tr>
                            </tbody>
                        </table>
                        <p><strong>오프셋 방향:</strong> <code>R2 tcp (Y-) ←──[Gantry R-center]──→ R1 tcp (Y+)</code></p>
                        <p><strong>동기화 흐름:</strong> TASK1: FALSE→복사→TRUE / TASK2: TRUE 대기 후 읽기</p>
                        <p><strong>결과:</strong> P-Start 이후 PERS 타이밍 문제 해결, 매 실행시 P-Start 불필요</p>
                    </div>

                    <div style="background:#f8f9fa; padding:1rem; border-radius:5px; margin-bottom:1.5rem; border-left:4px solid #e74c3c;">
                        <h3 style="margin-top:0; border:none;">[1.8.56] - 2026-01-12 17:30</h3>
                        <p><strong>작업자:</strong> Claude/심태양 | <strong>관련 이슈:</strong> TCP 거리 100~173mm 변동 (목표 200mm)</p>
                        <p><strong>변경 파일:</strong> <code>ConfigModule.mod</code>, <code>VersionModule.mod</code></p>
                        <table style="margin:0.5rem 0;">
                            <thead><tr><th>유형</th><th>내용</th></tr></thead>
                            <tbody>
                                <tr><td style="color:#f39c12">CHANGE</td><td><code>MODE2_TCP_OFFSET_R2_Y := -100</code> → <code>+100</code></td></tr>
                                <tr><td style="color:#27ae60">ADD</td><td>좌표 변환 분석 코멘트 추가</td></tr>
                            </tbody>
                        </table>
                        <p><strong>원인 분석:</strong> Floor Y effect = (488 + offset - 488) × cos(R) = offset × cos(R). 따라서 offset=-100이면 Robot1과 같은 방향.</p>
                        <p><strong>테스트 결과:</strong> 테스트 예정 (Y거리 = 200×cos(R) 확인 필요)</p>
                    </div>

                    <div style="background:#f8f9fa; padding:1rem; border-radius:5px; margin-bottom:1.5rem; border-left:4px solid #f39c12;">
                        <h3 style="margin-top:0; border:none;">[1.8.55] - 2026-01-12</h3>
                        <p><strong>작업자:</strong> Claude/심태양 | <strong>관련 이슈:</strong> Robot2 488mm 보정 분석</p>
                        <p><strong>변경 파일:</strong> <code>Rob2_MainModule.mod</code> (시도 후 롤백)</p>
                        <p><strong>시도:</strong> offset_tcp.y에서 488mm 제거</p>
                        <p><strong>결과:</strong> ❌ Joint Out of Range (50027) 발생 - Robot2 도달 범위 초과</p>
                        <p><strong>결론:</strong> 488mm 유지 필요, offset 부호 변경으로 해결 (v1.8.56)</p>
                    </div>

                    <div style="background:#f8f9fa; padding:1rem; border-radius:5px; margin-bottom:1.5rem; border-left:4px solid #3498db;">
                        <h3 style="margin-top:0; border:none;">[1.8.54] - 2026-01-10 10:30</h3>
                        <p><strong>작업자:</strong> Claude/심태양 | <strong>관련 이슈:</strong> Robot1 TCP 방향 변경 문제</p>
                        <p><strong>변경 파일:</strong> <code>MainModule.mod</code></p>
                        <p><strong>변경 라인:</strong> 2183, 2240-2241, 2270, 2296-2298</p>
                        <table style="margin:0.5rem 0;">
                            <thead><tr><th>유형</th><th>내용</th><th>라인</th></tr></thead>
                            <tbody>
                                <tr><td style="color:#27ae60">ADD</td><td><code>VAR robjoint robot1_offset_joints</code></td><td>2183</td></tr>
                                <tr><td style="color:#27ae60">ADD</td><td><code>robot1_offset_joints := current_gantry.robax</code></td><td>2241</td></tr>
                                <tr><td style="color:#27ae60">ADD</td><td><code>test_pos.robax := robot1_offset_joints</code></td><td>2270</td></tr>
                                <tr><td style="color:#e74c3c">REMOVE</td><td>MoveJ offset_tcp in loop (6 lines)</td><td>2296-2301</td></tr>
                            </tbody>
                        </table>
                        <p><strong>테스트 결과:</strong> ✅ Robot1 자세 유지 확인</p>
                    </div>

                    <h3>[1.8.53] - 2026-01-10</h3>
                    <ul>
                        <li><strong>FIX:</strong> MoveAbsJ 후 <code>current_gantry.extax</code> 재읽기로 Mode2 오프셋 유지.</li>
                        <li><strong>FEAT:</strong> Mode2 TP 로그 세분화(각 단계/좌표/오프셋 상태 출력).</li>
                        <li><strong>FEAT:</strong> <code>tp_messages.txt</code> 기록 추가(현장 디버깅 용).</li>
                        <li><strong>DOCS:</strong> Mode2 3개 위치 CSV 결과 최신화.</li>
                    </ul>
                    <h3>[1.8.52] - 2026-01-09</h3>
                    <ul>
                        <li><strong>REFACTOR:</strong> ConfigModule.mod / VersionModule.mod 분리.</li>
                        <li><strong>REFACTOR:</strong> 버전 상수는 VersionModule에서만 관리(TASK1_VERSION 분리).</li>
                        <li><strong>DOCS:</strong> 모듈 로드 순서 및 PERS 설정 가이드 추가.</li>
                    </ul>
                    <h3>[1.8.51] - 2026-01-09</h3>
                    <ul>
                        <li><strong>REFACTOR:</strong> config.txt 파싱 제거, PERS 설정으로 전환.</li>
                        <li><strong>FIX:</strong> ReadStr hang 재발 방지(파일 I/O 제거).</li>
                    </ul>
                    <h3>[1.8.50 ~ 1.8.45] - 2026-01-08</h3>
                    <ul>
                        <li><strong>DIAG:</strong> Mode2 config 파싱 구간 상세 로그 추가.</li>
                        <li><strong>FIX:</strong> RAPID <code>CONTINUE</code> 제거 및 안전 루프 적용.</li>
                        <li><strong>FIX:</strong> ReadStr <code>\RemoveCR</code> 복원 및 단일 패스 파싱 시도.</li>
                        <li><strong>DIAG:</strong> Mode2 로그 파일 Open/Close 반복 제거.</li>
                    </ul>
                    <h3>[1.8.21] - 2026-01-08</h3>
                    <ul>
                        <li><strong>DOCS:</strong> Mode2 랜덤 타겟 검증 테스트(v1.8.21) 결과 기록.</li>
                        <li><strong>DOCS:</strong> "향후 계획"의 복합 이동 검증 완료 처리.</li>
                        <li><strong>DOCS:</strong> 역기구학 논의 구조화.</li>
                    </ul>
                    <h3>[1.4.0] - 2026-01-08</h3>
                    <ul>
                        <li><strong>FEAT:</strong> '시각화' 탭에 현재 발생 중인 `50050` 오류에 대한 설명과 해결 방안을 담은 경고창 추가.</li>
                    </ul>
                    <h3>[1.3.0] - 2026-01-08</h3>
                    <ul>
                        <li><strong>FEAT:</strong> 페이지 구조를 탭 인터페이스로 전면 개편.</li>
                        <li><strong>FEAT:</strong> '변경 기록' 탭을 추가하고 v1.0.0부터의 이력 정리.</li>
                        <li><strong>DOCS:</strong> 기존 모든 설명 자료를 각 탭으로 통합하여 단일 파일로 관리.</li>
                    </ul>
                    <h3>[1.2.0] - 2026-01-07</h3>
                    <ul>
                        <li><strong>DOCS:</strong> 향후 과제(복합 이동 검증, 역기구학 문제)에 대한 설명 섹션 추가.</li>
                    </ul>
                    <h3>[1.1.0] - 2026-01-06</h3>
                    <ul>
                        <li><strong>DOCS:</strong> 로봇 1과 2의 TCP 좌표 계산 방식 차이를 설명하는 가이드 및 순서도 이미지 추가.</li>
                        <li><strong>DOCS:</strong> 회전 행렬 계산 원리 설명에 실제 JavaScript 코드 예시 추가.</li>
                        <li><strong>FIX:</strong> CSS 스타일을 수정하여 설명 영역의 수식 텍스트가 배경과 겹치는 문제 해결.</li>
                    </ul>
                    <h3>[1.0.0] - 2026-01-05</h3>
                    <ul>
                        <li><strong>FEAT:</strong> 갠트리 시스템의 2D 상면도 시각화 기능 최초 생성.</li>
                        <li><strong>FEAT:</strong> R축 각도 조절 슬라이더 및 실시간 계산 과정 표시 기능 구현.</li>
                        <li><strong>FIX:</strong> 시각화의 초기 좌표계가 X, Y축 뒤바뀌어 표시되던 버그 수정.</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Tab Logic ---
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(button.dataset.tab).classList.add('active');
            });
        });

        // --- Visualization Logic ---
        const canvas = document.getElementById('gantryCanvas');
        const ctx = canvas.getContext('2d');
        const slider = document.getElementById('angle-slider');
        const angleLabel = document.getElementById('angle-label');
        const calcOutput = document.getElementById('calc-output');

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const scale = 0.4;
        const robotBaseOffsetY = 488;

        function drawGrid() {
            ctx.beginPath();
            ctx.strokeStyle = '#dfe4ea';
            for (let x = 0; x <= canvas.width; x += 50) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            for (let y = 0; y <= canvas.height; y += 50) {
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            ctx.stroke();
        }

        function drawAxes() {
            ctx.beginPath();
            ctx.strokeStyle = '#95a5a6';
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            ctx.fillStyle = '#7f8c8d';
            ctx.font = '12px sans-serif';
            ctx.fillText('Floor Y+', centerX + 5, 15);
            ctx.fillText('Floor X+', canvas.width - 50, centerY - 10);
        }

        function drawSystem(angle) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawAxes();

            const angleRad = angle * Math.PI / 180;
            const cos = Math.cos(angleRad);
            const sin = Math.sin(angleRad);

            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
            ctx.fillStyle = '#c0392b';
            ctx.fill();
            ctx.fillText('R-Axis Center', centerX + 10, centerY - 10);

            ctx.beginPath();
            ctx.strokeStyle = '#e67e22';
            ctx.lineWidth = 2;
            ctx.moveTo(centerX - 6, centerY - 6);
            ctx.lineTo(centerX + 6, centerY + 6);
            ctx.moveTo(centerX + 6, centerY - 6);
            ctx.lineTo(centerX - 6, centerY + 6);
            ctx.stroke();
            ctx.fillText('TCP', centerX + 10, centerY + 20);
            ctx.lineWidth = 1;

            const r1_initial = { x: 0, y: robotBaseOffsetY };
            const r1_rotated = { x: r1_initial.x * cos - r1_initial.y * sin, y: r1_initial.x * sin + r1_initial.y * cos };
            const r1_canvas_x = centerX + r1_rotated.x * scale;
            const r1_canvas_y = centerY - r1_rotated.y * scale;

            const r2_initial = { x: 0, y: -robotBaseOffsetY };
            const r2_rotated = { x: r2_initial.x * cos - r2_initial.y * sin, y: r2_initial.x * sin + r2_initial.y * cos };
            const r2_canvas_x = centerX + r2_rotated.x * scale;
            const r2_canvas_y = centerY - r2_rotated.y * scale;

            ctx.beginPath();
            ctx.rect(r1_canvas_x - 15, r1_canvas_y - 15, 30, 30);
            ctx.fillStyle = 'rgba(41, 128, 185, 0.8)';
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = '12px sans-serif';
            ctx.fillText('R1', r1_canvas_x - 7, r1_canvas_y + 5);

            ctx.beginPath();
            ctx.rect(r2_canvas_x - 15, r2_canvas_y - 15, 30, 30);
            ctx.fillStyle = 'rgba(39, 174, 96, 0.8)';
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.fillText('R2', r2_canvas_x - 7, r2_canvas_y + 5);

            ctx.beginPath();
            ctx.strokeStyle = '#2c3e50';
            ctx.setLineDash([5, 5]);
            ctx.moveTo(r1_canvas_x, r1_canvas_y);
            ctx.lineTo(centerX, centerY);
            ctx.moveTo(r2_canvas_x, r2_canvas_y);
            ctx.lineTo(centerX, centerY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            updateCalculationText(angle, cos, sin, r1_initial, r1_rotated, r2_initial, r2_rotated);
        }
        
        function updateCalculationText(angle, cos, sin, r1_i, r1_r, r2_i, r2_r) {
             calcOutput.textContent = `R축 각도 (θ) = ${angle.toFixed(1)}°

Rotation Matrix:
[ cos(θ), -sin(θ) ]  [ ${cos.toFixed(2)}, ${-sin.toFixed(2)} ]
[ sin(θ),  cos(θ) ]  [ ${sin.toFixed(2)},  ${cos.toFixed(2)} ]

--- Robot 1 ---
초기 좌표: [${r1_i.x}, ${r1_i.y}]
계산:
x' = ${r1_i.x}*${cos.toFixed(2)} - ${r1_i.y}*${sin.toFixed(2)}
y' = ${r1_i.x}*${sin.toFixed(2)} + ${r1_i.y}*${cos.toFixed(2)}
결과 좌표: [${r1_r.x.toFixed(1)}, ${r1_r.y.toFixed(1)}]

--- Robot 2 ---
초기 좌표: [${r2_i.x}, ${r2_i.y}]
계산:
x' = ${r2_i.x}*${cos.toFixed(2)} - ${r2_i.y}*${sin.toFixed(2)}
y' = ${r2_i.x}*${sin.toFixed(2)} + ${r2_i.y}*${cos.toFixed(2)}
결과 좌표: [${r2_r.x.toFixed(1)}, ${r2_r.y.toFixed(1)}]`;
        }

        slider.addEventListener('input', () => {
            const angle = parseFloat(slider.value);
            angleLabel.textContent = `${angle.toFixed(1)}°`;
            drawSystem(angle);
        });

        // Initial draw
        drawSystem(parseFloat(slider.value));
    </script>
</body>
</html>
