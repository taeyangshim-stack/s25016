<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>S25016 PlanB 상위제어 UI 연동 오류 조치 보고서</title>
<style>
  body { font-family: 'Malgun Gothic', 'Apple SD Gothic Neo', sans-serif; margin: 40px; color: #333; line-height: 1.8; font-size: 14px; max-width: 1100px; }
  h1 { color: #1a365d; border-bottom: 3px solid #2b6cb0; padding-bottom: 10px; font-size: 22px; }
  h2 { color: #2b6cb0; border-left: 4px solid #2b6cb0; padding-left: 12px; margin-top: 40px; font-size: 17px; }
  h3 { color: #2c5282; margin-top: 25px; font-size: 15px; }
  h4 { color: #4a5568; margin-top: 20px; font-size: 14px; }
  table { border-collapse: collapse; width: 100%; margin: 15px 0; font-size: 13px; }
  th { background: #2b6cb0; color: #fff; padding: 10px 12px; text-align: left; }
  td { border: 1px solid #ccc; padding: 8px 12px; vertical-align: top; }
  tr:nth-child(even) { background: #f7fafc; }
  .error-box { background: #fff5f5; border: 1px solid #fc8181; border-radius: 6px; padding: 15px; margin: 15px 0; }
  .fix-box { background: #f0fff4; border: 1px solid #68d391; border-radius: 6px; padding: 15px; margin: 15px 0; }
  .info-box { background: #ebf8ff; border: 1px solid #63b3ed; border-radius: 6px; padding: 15px; margin: 15px 0; }
  .warn-box { background: #fffaf0; border: 1px solid #ed8936; border-radius: 6px; padding: 15px; margin: 15px 0; }
  .grey-box { background: #f7fafc; border: 1px solid #e2e8f0; border-radius: 6px; padding: 15px; margin: 15px 0; }
  code { background: #edf2f7; padding: 2px 6px; border-radius: 3px; font-family: 'Consolas', 'Courier New', monospace; font-size: 13px; }
  pre { background: #1a202c; color: #e2e8f0; padding: 15px; border-radius: 6px; overflow-x: auto; font-size: 12px; line-height: 1.6; }
  .tag { display: inline-block; padding: 2px 8px; border-radius: 3px; font-size: 11px; font-weight: bold; }
  .tag-error { background: #fed7d7; color: #c53030; }
  .tag-fix { background: #c6f6d5; color: #276749; }
  .tag-new { background: #bee3f8; color: #2a4365; }
  .tag-warn { background: #fefcbf; color: #975a16; }
  .header-info td { border: none; padding: 5px 15px; }
  .signature { margin-top: 40px; padding-top: 20px; border-top: 1px solid #e2e8f0; color: #718096; font-size: 13px; }
  .diagram { background: #f7fafc; border: 1px solid #cbd5e0; border-radius: 6px; padding: 20px; margin: 15px 0; font-family: 'Consolas', monospace; font-size: 12px; line-height: 1.6; white-space: pre; overflow-x: auto; }
  .field-desc { font-size: 12px; color: #718096; }
  ul, ol { margin: 8px 0; padding-left: 25px; }
  li { margin: 4px 0; }
</style>
</head>
<body>

<h1>S25016 PlanB 상위제어 UI 연동 오류 분석 및 조치 보고서</h1>

<table style="border: 1px solid #e2e8f0; background: #f7fafc; border-radius: 6px;" class="header-info">
<tr><td style="font-weight:bold; width:130px;">프로젝트</td><td>S25016 삼성중공업 거제조선소 34bay 자동용접 로봇 시스템</td></tr>
<tr><td style="font-weight:bold;">대상 라인</td><td>B라인 PlanB (SpGantry_1200_526406)</td></tr>
<tr><td style="font-weight:bold;">컨트롤러</td><td>ABB IRC5 / RobotWare 6.16.1028 (RobotStudio)</td></tr>
<tr><td style="font-weight:bold;">상위 UI</td><td>SubAssemblyWeldingSystem_BLine_PlanB (디파인시스템)</td></tr>
<tr><td style="font-weight:bold;">작성일</td><td>2026-02-11</td></tr>
<tr><td style="font-weight:bold;">작성자</td><td>심태양 / 에스피시스템스</td></tr>
<tr><td style="font-weight:bold;">문서 분류</td><td>상위제어 UI 연동 테스트 - 오류 분석 및 조치 보고</td></tr>
</table>

<!-- ============================================ -->
<h2>1. 개요</h2>
<!-- ============================================ -->

<h3>1.1 배경</h3>
<p>
S25016 프로젝트는 삼성중공업 거제조선소 34bay에 설치되는 자동용접 로봇 시스템으로,
2대의 ABB IRB 1200-5/0.9 로봇이 갠트리(4축: X, Y, Z, R) 위에 탑재되어 동시 용접을 수행합니다.
</p>
<p>
로봇 제어 프로그램은 두 가지 버전이 존재합니다:
</p>
<ul>
<li><strong>PlanA</strong> (레퍼런스): 실 컨트롤러에서 운용 중인 검증된 프로그램. 갠트리를 별도 Mechanical Unit Group으로 구성하며, 10개의 RAPID 태스크를 사용합니다.</li>
<li><strong>PlanB</strong> (개발중): RobotStudio 가상 컨트롤러 기반 개발 프로그램. 갠트리를 Robot1의 외부축으로 통합 구성하며, 코드 간소화를 위해 태스크를 8개로 축소했습니다.</li>
</ul>

<h3>1.2 테스트 목적</h3>
<p>
디파인시스템에서 개발한 상위제어 UI (<code>DF.SubAssembly.MainGui</code>)를
PlanB 로봇 컨트롤러와 연동하여, UI가 로봇의 실시간 상태(위치, 토크, 용접 파라미터)를
정상적으로 읽고 제어 명령을 전달할 수 있는지 검증하고자 하였습니다.
</p>

<h3>1.3 연동 구조</h3>
<p>
상위 UI는 ABB PC SDK (<code>ABB.Robotics.Controllers.PC.dll</code>)를 통해 로봇 컨트롤러에 접속합니다.
UI는 초기화 시 미리 정의된 RAPID 심볼 경로로 변수를 바인딩하고,
이후 실시간으로 해당 변수의 값을 Read/Write합니다.
</p>

<div class="diagram">
+---------------------------+          ABB PC SDK          +---------------------------+
|    상위제어 UI (PC)       | &lt;========================&gt; |    ABB IRC5 컨트롤러      |
|  DF.SubAssembly.MainGui   |    Ethernet TCP/IP 접속      |  RobotWare 6.16           |
+---------------------------+                              +---------------------------+
|                           |     RapidData Subscribe      |                           |
|  MonRobs 화면 표시        | &lt;--- T_BG.Static.          |  TASK7(T_BG) Static.mod   |
|  (갠트리 위치, 로봇 TCP)  |       MonitorPosition        |  -> rUpdateCurrentPosition|
|                           |                              |                           |
|  토크 모니터링 그래프     | &lt;--- T_BG.Static.nTorques  |  -> rReadMotorTorque      |
|                           |                              |                           |
|  용접 상태 표시           | &lt;--- T_BG.Static.          |  -> rUpdateWeldStatus     |
|  (시간, 각도, 아크)       |       stWeld1 / stWeld2      |                           |
|                           |                              |                           |
|  워밍업 사이클 표시       | &lt;--- T_Head.Head_Data.     |  TASK8(T_Head)            |
|                           |       nWarmUpCycle            |  Head_Data.mod            |
|                           |                              |                           |
|  용접전압/WFS 표시        | &lt;--- T_Teaching.Teaching.  |  TASK9(T_Teaching)        |
|  (목표값 + 실시간 보정)   |       nCurrentTargetVoltage  |  Teaching.mod             |
|                           |       nCurrentTargetWfs      |                           |
|                           |                              |                           |
|  운전자 실시간 보정 입력  | ---&gt; T_Teaching.Teaching.  |  -> nRealTimeVoltage{2}   |
|  (전압/WFS 미세 조정)     |       nRealTimeVoltage       |  -> nRealTimeWfs{2}       |
|                           |       nRealTimeWfs           |                           |
+---------------------------+                              +---------------------------+
</div>

<p>
UI가 RAPID 변수를 바인딩할 때 사용하는 경로 형식은 <code>[태스크명].[모듈명].[변수명]</code>입니다.
예를 들어 <code>T_BG.Static.MonitorPosition</code>은 "T_BG 태스크의 Static 모듈에 있는 MonitorPosition 변수"를 의미합니다.
이 경로가 컨트롤러 내에 존재하지 않으면 <code>GenericControllerException - RAPID symbol was not found</code> 에러가 발생합니다.
</p>

<h3>1.4 테스트 결과</h3>
<div class="error-box">
<strong>결과: 연동 실패</strong><br>
UI 초기화 시 <strong>9건의 RAPID 심볼 미발견 오류</strong>가 발생하여 정상 연결이 불가하였습니다.<br>
에러 로그: <code>SubAssemblyWeldingSystem_BLine_PlanB/logs/RapidInitFailReport.txt</code>
</div>

<!-- ============================================ -->
<h2>2. 에러 상세 내용</h2>
<!-- ============================================ -->

<h3>2.1 에러 로그 원문</h3>
<div class="grey-box" style="font-family: 'Consolas', monospace; font-size: 12px; white-space: pre-wrap;">
==================================================
Rapid Initialize Fail Report  2026-02-11 20:22:02
Fail Count: 9
--------------------------------------------------
- Key: MonRobs
  Target: T_BG.Static.MonitorPosition (UserRapidDataItem)
  Reason: Exception: GenericControllerException -  RAPID symbol was not found.

- Key: CurrentTorque
  Target: T_BG.Static.nTorques (ArrayRapidDataItem)
  Reason: Exception: GenericControllerException -  RAPID symbol was not found.

- Key: WeldDataStatus
  Target: T_BG.Static.stWeld1 (UserRapidDataItem)
  Reason: Exception: GenericControllerException -  RAPID symbol was not found.

- Key: WeldDataStatus2
  Target: T_BG.Static.stWeld2 (UserRapidDataItem)
  Reason: Exception: GenericControllerException -  RAPID symbol was not found.

- Key: WarmUpPeriod
  Target: T_Head.Head_Data.nWarmUpCycle (NumRapidDataItem)
  Reason: Exception: GenericControllerException -  RAPID symbol was not found.

- Key: CurrentTargetVoltage
  Target: T_Teaching.Teaching.nCurrentTargetVoltage (ArrayRapidDataItem)
  Reason: Exception: GenericControllerException -  RAPID symbol was not found.

- Key: CurrentTargetWfs
  Target: T_Teaching.Teaching.nCurrentTargetWfs (ArrayRapidDataItem)
  Reason: Exception: GenericControllerException -  RAPID symbol was not found.

- Key: RealTimeVoltage
  Target: T_Teaching.Teaching.nRealTimeVoltage (ArrayRapidDataItem)
  Reason: Exception: GenericControllerException -  RAPID symbol was not found.

- Key: RealTimeWfs
  Target: T_Teaching.Teaching.nRealTimeWfs (ArrayRapidDataItem)
  Reason: Exception: GenericControllerException -  RAPID symbol was not found.
</div>

<h3>2.2 에러 분류 요약</h3>
<table>
<tr>
  <th>그룹</th>
  <th>태스크</th>
  <th>에러 건수</th>
  <th>원인 요약</th>
</tr>
<tr style="background:#fff5f5;">
  <td><strong>그룹 1</strong></td>
  <td><code>T_BG</code> (백그라운드)</td>
  <td>4건</td>
  <td>PlanB TASK7의 Static.mod에 UI 필요 변수 및 모니터링 로직 누락</td>
</tr>
<tr style="background:#fff5f5;">
  <td><strong>그룹 2</strong></td>
  <td><code>T_Head</code> (상위 제어)</td>
  <td>1건</td>
  <td>Head_Data.mod에 <code>nWarmUpCycle</code> 변수 미정의 (UI 신규 요구)</td>
</tr>
<tr style="background:#fff5f5;">
  <td><strong>그룹 3</strong></td>
  <td><code>T_Teaching</code> (용접 파라미터)</td>
  <td>4건</td>
  <td>PlanB에 T_Teaching 태스크 자체가 존재하지 않음</td>
</tr>
</table>

<!-- ============================================ -->
<h2>3. 원인 분석</h2>
<!-- ============================================ -->

<h3>3.1 하드웨어 구성 (PlanA / PlanB 공통)</h3>
<p>두 Plan은 동일한 물리 하드웨어(컨트롤러 S/N: 1200-526406)를 사용하며, 소프트웨어 구성만 다릅니다.</p>

<table>
<tr><th>구성요소</th><th>사양</th><th>비고</th></tr>
<tr><td><strong>Robot1</strong> (ROB_1)</td><td>IRB 1200-5/0.9 Type B</td><td>용접로봇 #1, Lincoln ArcLink-XT, SmarTac IO, WeldGuide MultiPass</td></tr>
<tr><td><strong>Robot2</strong> (ROB_2)</td><td>IRB 1200-5/0.9 Type B</td><td>용접로봇 #2, 동일 용접기 옵션</td></tr>
<tr><td><strong>Robot3</strong> (갠트리)</td><td>IRB 460/640 계열 드라이브</td><td>4축 갠트리 (X, Y, Z, R) + ADU-790A x3</td></tr>
<tr><td><strong>Linked Motor</strong></td><td>ELM_X</td><td>X1/X2 축 전자식 동기 (GantryRob_7 X축에 연동)</td></tr>
<tr><td><strong>용접기</strong></td><td>Lincoln Power Wave x2</td><td>LincolnArcLink-XT v1.06.5.0, DeviceNet 통신</td></tr>
<tr><td><strong>주요 옵션</strong></td><td colspan="2">MultiMove Coordinated (604-1), Multitasking (623-1), DeviceNet Master/Slave (709-1), Collision Detection (613-1), Sensor Interface (628-1)</td></tr>
</table>

<h3>3.2 소프트웨어 구성 차이: PlanA vs PlanB</h3>

<h4>3.2.1 Mechanical Unit Group 구성</h4>
<p>가장 근본적인 차이는 갠트리 축의 할당 방식입니다.</p>

<table>
<tr><th>항목</th><th>PlanA (실 컨트롤러)</th><th>PlanB (RobotStudio)</th></tr>
<tr>
  <td><strong>RobotWare</strong></td>
  <td>6.16.<strong>0025</strong></td>
  <td>6.16.<strong>1028</strong></td>
</tr>
<tr>
  <td><strong>rob1 그룹</strong></td>
  <td>ROB_1 (로봇만)<br>Motion Planner 1</td>
  <td>ROB_1 + <strong>GantryRob + ELM_X</strong><br>Motion Planner 1 (갠트리 통합)</td>
</tr>
<tr>
  <td><strong>rob2 그룹</strong></td>
  <td>ROB_2<br>Motion Planner 2</td>
  <td>ROB_2<br>Motion Planner 2</td>
</tr>
<tr>
  <td><strong>Gantry 그룹</strong></td>
  <td><strong>GantryRob_7 + ELM_X</strong><br>Motion Planner 3 (독립)</td>
  <td style="color:#c53030;"><strong>없음</strong> (rob1에 통합)</td>
</tr>
</table>

<div class="info-box">
<strong>영향:</strong> PlanA에서는 갠트리가 별도 Motion Planner를 가지므로 <code>T_Gantry</code> 태스크에서 독립적으로 제어 가능합니다.
PlanB에서는 갠트리가 Robot1의 외부축으로 통합되어 있어 <code>T_ROB1</code> 태스크에서만 갠트리 모션이 가능하며,
별도 T_Gantry 태스크가 필요 없습니다.
이 구조적 차이로 인해 PlanB의 전체 태스크 구성이 PlanA와 달라졌습니다.
</div>

<h4>3.2.2 RAPID 태스크 구조 비교</h4>

<table>
<tr>
  <th style="width:100px;">TASK<br>폴더</th>
  <th style="width:120px;">태스크명</th>
  <th>PlanA (10 TASK)</th>
  <th>PlanB (8 TASK) — 조치 전</th>
  <th style="width:80px;">UI 영향</th>
</tr>
<tr>
  <td>TASK1</td>
  <td><strong>T_ROB1</strong></td>
  <td>Rob1_MainModule (137KB)<br>+ Rob1_TeachingData (0.7KB)<br>+ T_ROB1_Function (1.7KB)<br><span class="field-desc">Robot1 용접 제어, 모션 제어</span></td>
  <td>MainModule (201KB)<br>+ ConfigModule (36KB)<br>+ VersionModule (28KB)<br><span class="field-desc">Robot1 + 갠트리 통합 제어, 설정/버전 분리 관리</span></td>
  <td>정상</td>
</tr>
<tr>
  <td>TASK2</td>
  <td><strong>T_ROB2</strong></td>
  <td>Rob2_MainModule (140KB)<br>+ Rob2_TeachingData (0.7KB)<br>+ T_ROB2_Function (1.8KB)<br><span class="field-desc">Robot2 용접 제어</span></td>
  <td>Rob2_MainModule (141KB)<br><span class="field-desc">Robot2 용접 제어 (동일)</span></td>
  <td>정상</td>
</tr>
<tr>
  <td>TASK3~6</td>
  <td>-</td>
  <td colspan="2" style="text-align:center;">(시스템 예약 빈 폴더)</td>
  <td>-</td>
</tr>
<tr>
  <td>TASK7</td>
  <td>PlanA: <strong>T_Gantry</strong><br>PlanB: <strong>T_BG</strong></td>
  <td>Gantry_MainModule (12KB)<br>+ Gantry_CheckPrecision (14KB)<br><span class="field-desc">갠트리 독립 모션 제어, 정밀도 검증</span></td>
  <td style="color:#c53030;">Static.mod (<strong>1.6KB</strong>)<br><span class="field-desc">updateCurrentPosition 1개 함수만 존재.<br>MonitorPosition, nTorques, stWeld1/2 모두 없음</span></td>
  <td><span class="tag tag-error">4건</span></td>
</tr>
<tr>
  <td>TASK8</td>
  <td><strong>T_Head</strong></td>
  <td>Head_MainModule (13KB)<br>+ Head_Data (53KB)<br>+ Head_MoveControl (116KB)<br>+ Head_Camera/Command/Function<br><span class="field-desc">상위 커맨드 디스패처, 갠트리+로봇 통합 제어</span></td>
  <td>동일 구조 (PlanA에서 이식)<br><span class="field-desc">단, <code>nWarmUpCycle</code> 변수 미포함</span></td>
  <td><span class="tag tag-error">1건</span></td>
</tr>
<tr style="background:#fff5f5;">
  <td>TASK9</td>
  <td>PlanA: <strong>T_BG</strong><br>PlanB: <strong>없음</strong></td>
  <td>Static.mod (<strong>16KB, 482줄</strong>)<br><span class="field-desc">백그라운드 모니터링 전담:<br>- 위치 모니터링 (MonitorPosition)<br>- 모터 토크 읽기 (nTorques)<br>- 용접 상태 관리 (stWeld1/2)<br>- 와이어 터치 감지<br>- 에러 터치 감지<br>- 충격 센서 감시<br>- 홈 위치 알림</span></td>
  <td style="color:#c53030;"><strong>폴더 자체 없음</strong><br><span class="field-desc">PlanB 개발 시 TASK9를 삭제하고<br>일부 기능을 TASK1(MainModule)에 통합.<br>그러나 UI 인터페이스용 변수는 미이식.</span></td>
  <td><span class="tag tag-error">상기 4건</span></td>
</tr>
<tr style="background:#fff5f5;">
  <td>TASK10</td>
  <td>PlanA: <strong>T_Teaching</strong><br>PlanB: <strong>없음</strong></td>
  <td>Teaching.mod (1.6KB)<br><span class="field-desc">실시간 용접 파라미터 계산:<br>- 현재 스텝 목표전압/WFS 산출<br>- 운전자 실시간 보정값 반영<br>- UI가 Read/Write하는 4개 변수 관리</span></td>
  <td style="color:#c53030;"><strong>폴더 자체 없음</strong><br><span class="field-desc">PlanB에서 T_Teaching 태스크를 삭제.<br>SYS.cfg에도 미정의.</span></td>
  <td><span class="tag tag-error">4건</span></td>
</tr>
</table>

<h3>3.3 에러별 상세 원인 분석</h3>

<!-- ===== 그룹 1 ===== -->
<h4>그룹 1: T_BG.Static.* (4건) — 백그라운드 모니터링 변수 누락</h4>

<p>
PlanA에서 <code>T_BG</code> (TASK9) 태스크의 <code>Static.mod</code>는 백그라운드에서 끊임없이 실행되며,
로봇 시스템의 실시간 상태를 모니터링합니다. 이 태스크는 <code>STATIC</code> 타입으로 설정되어 있어
프로그램 시작/정지와 무관하게 항상 동작하며, UI가 필요한 실시간 데이터를 PERS 변수에 저장합니다.
</p>
<p>
PlanB에서는 이 기능을 간소화하여 TASK7의 Static.mod에 갠트리 X축 현재 위치만 업데이트하는
단순 루틴 하나만 남겨두었습니다. 그 결과 UI가 바인딩하려는 4개 변수가 모두 존재하지 않게 되었습니다.
</p>

<p><strong>에러 1: <code>MonitorPosition</code> (monRobs 타입)</strong></p>
<div class="info-box">
<strong>용도:</strong> 갠트리 4축 + Robot1 6축 + Robot2 6축의 실시간 위치를 하나의 구조체에 통합하여 UI에 제공합니다.
UI는 이 데이터로 3D 로봇 시각화, 갠트리 위치 표시, TCP 좌표 표시를 수행합니다.
</div>

<table>
<tr><th colspan="3">monRobs RECORD 구조 (5개 필드)</th></tr>
<tr><th>필드명</th><th>타입</th><th>내용</th></tr>
<tr><td><code>monExt</code></td><td>extjoint</td><td>갠트리 외부축 (eax_a=X, eax_b=Y, eax_c=Z, eax_d=R)<br><span class="field-desc">HOME 기준 Floor 좌표로 변환된 값. ConvertJointToExtCoord()에서 물리축값을 변환합니다.</span></td></tr>
<tr><td><code>monJoint1</code></td><td>robjoint</td><td>Robot1 조인트 각도 (rax_1~rax_6)<br><span class="field-desc">CJointT(\TaskName:="T_ROB1")에서 읽은 현재 조인트값</span></td></tr>
<tr><td><code>monJoint2</code></td><td>robjoint</td><td>Robot2 조인트 각도 (rax_1~rax_6)<br><span class="field-desc">CJointT(\TaskName:="T_ROB2")에서 읽은 현재 조인트값</span></td></tr>
<tr><td><code>monPose1</code></td><td>pose (trans+rot)</td><td>Robot1 TCP 위치 (Floor 좌표계)<br><span class="field-desc">CalcCurrentTcp(\R1)로 계산. 갠트리 위치 + R축 회전 고려한 절대 TCP 좌표.</span></td></tr>
<tr><td><code>monPose2</code></td><td>pose (trans+rot)</td><td>Robot2 TCP 위치 (Floor 좌표계)<br><span class="field-desc">CalcCurrentTcp(\R2)로 계산. Robot2 좌표 변환 공식(2R formula) 적용.</span></td></tr>
</table>

<p><strong>관련 프로시저 (PlanA TASK9):</strong></p>
<pre>
PROC rUpdateCurrentPosition()
    VAR jointtarget jct1;
    VAR jointtarget jct2;
    VAR robtarget pct1;
    VAR robtarget pct2;

    ! 갠트리 물리축값을 Floor 좌표로 변환
    MonitorPosition.monExt := ConvertJointToExtCoord(CJointT(\TaskName:="T_Gantry"));

    ! Robot1/Robot2 현재 조인트값
    jct1 := CJointT(\TaskName:="T_ROB1");
    jct2 := CJointT(\TaskName:="T_ROB2");

    ! R축 회전을 고려한 Floor 좌표계 TCP 위치 계산
    pct1 := CalcCurrentTcp(\R1);  ! Robot1
    pct2 := CalcCurrentTcp(\R2);  ! Robot2

    ! 구조체에 저장 (UI가 실시간 읽기)
    MonitorPosition.monJoint1 := jct1.robax;
    MonitorPosition.monJoint2 := jct2.robax;
    MonitorPosition.monPose1.trans := pct1.trans;
    MonitorPosition.monPose1.rot := pct1.rot;
    MonitorPosition.monPose2.trans := pct2.trans;
    MonitorPosition.monPose2.rot := pct2.rot;

    ! 아날로그 출력으로 갠트리 X 위치 전송
    SetAO cgo05_AxisX_Current, Round(MonitorPosition.monExt.eax_a);
ENDPROC
</pre>

<p><strong>에러 2: <code>nTorques{18}</code></strong></p>
<div class="info-box">
<strong>용도:</strong> 18축 모터 토크값을 배열로 관리합니다. UI는 이 데이터로 과부하 감지, 충돌 감시, 토크 트렌드 그래프를 표시합니다.
</div>

<table>
<tr><th>인덱스</th><th>대상</th><th>Mechanical Unit</th><th>현재 상태</th></tr>
<tr><td>nTorques{1~6}</td><td>Robot1 축 1~6</td><td>ROB_1</td><td><span class="tag tag-warn">주석처리</span> (PlanA에서도 비활성)</td></tr>
<tr><td>nTorques{7~12}</td><td>Robot2 축 1~6</td><td>ROB_2</td><td><span class="tag tag-warn">주석처리</span> (PlanA에서도 비활성)</td></tr>
<tr><td>nTorques{13~16}</td><td>갠트리 X, Y, Z, R</td><td>GantryRob_7</td><td><span class="tag tag-fix">활성</span></td></tr>
<tr><td>nTorques{17}</td><td>예비</td><td>-</td><td>9E+09 (미사용)</td></tr>
<tr><td>nTorques{18}</td><td>Linked Motor X2</td><td>ELM_X</td><td><span class="tag tag-fix">활성</span></td></tr>
</table>

<p><strong>에러 3~4: <code>stWeld1</code>, <code>stWeld2</code> (StatusWeld 타입)</strong></p>
<div class="info-box">
<strong>용도:</strong> 각 로봇의 용접 진행 상태를 실시간으로 추적합니다. UI는 이 데이터로 용접 시간, 토치 각도, 아크 ON/OFF 상태, 분당 용접 횟수(CPM)를 표시합니다.
</div>

<table>
<tr><th colspan="3">StatusWeld RECORD 구조 (10개 필드)</th></tr>
<tr><th>필드명</th><th>타입</th><th>내용</th></tr>
<tr><td><code>WeldTimeForTotal</code></td><td>num</td><td>전체 사이클 경과 시간 (초)</td></tr>
<tr><td><code>WeldTimeForLine</code></td><td>num</td><td>현재 용접선 경과 시간 (초)</td></tr>
<tr><td><code>WorkingAngle</code></td><td>num</td><td>작업각 (도) — EulerZYX(\y, 토치자세)로 계산</td></tr>
<tr><td><code>TravelAngle</code></td><td>num</td><td>진행각 (도) — EulerZYX(\z, 토치자세)로 계산</td></tr>
<tr><td><code>StatusForArc</code></td><td>num</td><td>아크 상태 (1=ON, 0=OFF) — siLn1Arc_Est/siLn2Arc_Est 신호 기반</td></tr>
<tr><td><code>cpm</code></td><td>num</td><td>분당 용접 횟수 (Cuts Per Minute) — Welds{step}.cpm에서 읽기</td></tr>
<tr><td><code>rpm</code></td><td>num</td><td>예비 (현재 미사용)</td></tr>
<tr><td><code>nDummy8~10</code></td><td>num</td><td>예비 필드 (향후 확장용)</td></tr>
</table>

<!-- ===== 그룹 2 ===== -->
<h4>그룹 2: T_Head.Head_Data.nWarmUpCycle (1건) — 신규 UI 요구 변수</h4>

<p>
<code>nWarmUpCycle</code>은 <strong>PlanA의 Head_Data.mod에도 존재하지 않는</strong> UI 신규 추가 변수입니다.
</p>
<p>
PlanA의 Head_Data.mod에는 워밍업 관련 변수 3개가 정의되어 있습니다:
</p>
<table>
<tr><th>변수</th><th>값</th><th>용도</th></tr>
<tr><td><code>nWarmUp_Speed</code></td><td>10</td><td>워밍업 동작 속도 (mm/s)</td></tr>
<tr><td><code>nWarmUp_Distance</code></td><td>100</td><td>워밍업 왕복 거리 (mm)</td></tr>
<tr><td><code>nWarmUp_Count</code></td><td>2</td><td>워밍업 반복 횟수</td></tr>
</table>
<p>
UI가 요구하는 <code>nWarmUpCycle</code>은 <strong>현재 진행 중인 워밍업 사이클 카운트</strong>를 표시하기 위한 변수로 추정됩니다.
즉, <code>nWarmUp_Count</code>가 "목표 횟수"라면 <code>nWarmUpCycle</code>은 "현재 진행 횟수"에 해당합니다.
Head_MoveControl.mod의 워밍업 루프에서 이 변수를 업데이트하는 로직을 향후 추가해야 합니다.
</p>

<!-- ===== 그룹 3 ===== -->
<h4>그룹 3: T_Teaching.Teaching.* (4건) — 태스크 미존재</h4>

<p>
PlanB 개발 시 TASK10(T_Teaching)을 제거하고 Teaching 기능을 MainModule 커맨드 루프에 흡수하였으나,
상위 UI는 <strong>별도 T_Teaching 태스크에서 직접 RAPID 변수를 Read/Write</strong>하므로,
해당 태스크와 변수가 반드시 존재해야 합니다.
</p>

<p><strong>변수별 데이터 흐름:</strong></p>

<div class="diagram">
[Lincoln 용접기 #1]                    [Lincoln 용접기 #2]
   |  siLn1Current                        |  siLn2Current
   |  siLn1TouchActive                    |  siLn2TouchActive
   v                                      v
+-------------------------------------------------------+
|  T_Teaching (TASK10)  -  Teaching.mod                  |
|                                                        |
|  IF 용접전류 감지 OR 아크 ON:                          |
|    nCurrentTargetVoltage{1}                            |
|      = Welds1{현재스텝}.voltage + nRealTimeVoltage{1}  |
|    nCurrentTargetWfs{1}                                |
|      = Welds1{현재스텝}.wfs + nRealTimeWfs{1}          |
|  ELSE:                                                 |
|    nCurrentTargetVoltage{1} = 0  (비용접 상태)         |
|    nCurrentTargetWfs{1} = 0                            |
|                                                        |
|  Robot2도 동일 로직 (인덱스 {2})                       |
+-------------------------------------------------------+
         |                           ^
         | UI Read                   | UI Write
         v                           |
+-------------------------------------------------------+
|  상위제어 UI                                           |
|                                                        |
|  [화면 표시]              [운전자 실시간 조정]         |
|  목표 전압: 28.5V         전압 보정: +0.3V             |
|  목표 WFS: 12.0 m/min     WFS 보정: -0.2 m/min        |
+-------------------------------------------------------+
</div>

<table>
<tr><th>변수</th><th>타입</th><th>크기</th><th>방향</th><th>상세 설명</th></tr>
<tr>
  <td><code>nCurrentTargetVoltage{2}</code></td>
  <td>num 배열</td>
  <td>{1}=Robot1, {2}=Robot2</td>
  <td>RAPID &rarr; UI (Read)</td>
  <td>현재 용접 스텝의 <strong>기본 설정 전압 + 운전자 보정값</strong>의 합계.<br>
  <code>Welds1{nRunningStep{1}}.voltage + nRealTimeVoltage{1}</code><br>
  용접 비활성 시 0으로 리셋.</td>
</tr>
<tr>
  <td><code>nCurrentTargetWfs{2}</code></td>
  <td>num 배열</td>
  <td>{1}=Robot1, {2}=Robot2</td>
  <td>RAPID &rarr; UI (Read)</td>
  <td>현재 스텝의 <strong>기본 Wire Feed Speed + 운전자 보정값</strong>의 합계.<br>
  <code>Welds1{nRunningStep{1}}.wfs + nRealTimeWfs{1}</code></td>
</tr>
<tr>
  <td><code>nRealTimeVoltage{2}</code></td>
  <td>num 배열</td>
  <td>{1}=Robot1, {2}=Robot2</td>
  <td>UI &rarr; RAPID (Write)</td>
  <td>운전자가 UI에서 <strong>실시간으로 입력하는 전압 보정값</strong>.<br>
  양수=전압 증가, 음수=전압 감소. 기본값 0.</td>
</tr>
<tr>
  <td><code>nRealTimeWfs{2}</code></td>
  <td>num 배열</td>
  <td>{1}=Robot1, {2}=Robot2</td>
  <td>UI &rarr; RAPID (Write)</td>
  <td>운전자가 UI에서 <strong>실시간으로 입력하는 WFS 보정값</strong>.<br>
  양수=와이어 속도 증가, 음수=감소. 기본값 0.</td>
</tr>
</table>

<!-- ============================================ -->
<h2>4. 조치 내용</h2>
<!-- ============================================ -->

<div class="fix-box">
<strong>조치 방향:</strong> PlanA의 코드를 기반으로 PlanB에 누락된 TASK/변수/로직을 추가하여,
상위 UI가 기대하는 RAPID 심볼 경로를 모두 충족시킵니다.
기존 PlanB의 TASK1/TASK2 로직에는 영향을 주지 않으며,
백그라운드 태스크(T_BG, T_Teaching)만 추가/보강합니다.
</div>

<h3>4.1 TASK7/Static.mod 전면 교체 <span class="tag tag-fix">T_BG 4건 해결</span></h3>

<p>
기존 PlanB TASK7의 Static.mod (1.6KB, 단순 위치 업데이트만)를
PlanA TASK9의 전체 코드(16KB)로 교체합니다.
</p>

<table>
<tr><th>항목</th><th>변경 전 (PlanB)</th><th>변경 후</th></tr>
<tr>
  <td>파일 크기</td>
  <td>1.6 KB (49줄)</td>
  <td><strong>약 13 KB</strong> (PlanA TASK9 기반 이식)</td>
</tr>
<tr>
  <td>RECORD 정의</td>
  <td>없음</td>
  <td><code>monRobs</code> (5필드), <code>StatusWeld</code> (10필드), <code>pointgroup</code> (3필드), <code>targetdata</code> (17필드)</td>
</tr>
<tr>
  <td>UI 필수 변수</td>
  <td>없음</td>
  <td><code>MonitorPosition</code>, <code>nTorques{18}</code>, <code>stWeld1</code>, <code>stWeld2</code></td>
</tr>
<tr>
  <td>공유 PERS 변수</td>
  <td>없음</td>
  <td>stCommand, stReact{3}, nRunningStep{2}, Welds1/2/G{40}, tWeld1/2, wobjWeldLine1/2 등 <strong>약 50개</strong> 크로스 태스크 변수</td>
</tr>
<tr>
  <td>프로시저</td>
  <td><code>updateCurrentPosition</code> 1개</td>
  <td><strong>10개 프로시저</strong> + 3개 함수</td>
</tr>
<tr>
  <td>main() 루프</td>
  <td>단일 호출</td>
  <td>WHILE TRUE 무한 루프<br>(9개 프로시저 순환 호출)</td>
</tr>
</table>

<p><strong>포함된 프로시저 상세:</strong></p>
<table>
<tr><th>프로시저명</th><th>기능</th><th>호출 주기</th></tr>
<tr><td><code>rReadMotorTorque</code></td><td>갠트리 4축 + ELM_X 모터 토크를 GetMotorTorque로 읽어 nTorques에 저장</td><td>매 루프</td></tr>
<tr><td><code>rUpdateCurrentPosition</code></td><td>갠트리/로봇 위치를 읽어 MonitorPosition 구조체 갱신, cgo05_AxisX_Current 아날로그 출력</td><td>매 루프</td></tr>
<tr><td><code>rUpdateWeldStatus</code></td><td>용접 중 각도/시간/아크 상태를 계산하여 stWeld1/stWeld2 갱신, 갠트리 PosHold 시퀀스 관리</td><td>매 루프</td></tr>
<tr><td><code>rWireTouch1</code></td><td>Robot1 와이어 터치 감지 (siLn1Current + siLn1Voltage + siLn1TouchActive 조합)</td><td>매 루프</td></tr>
<tr><td><code>rWireTouch2</code></td><td>Robot2 와이어 터치 감지 (동일 로직)</td><td>매 루프</td></tr>
<tr><td><code>rNotifyHome</code></td><td>현재 위치가 HOME 범위(0.5mm 이내)인지 판정하여 po03_Home 출력</td><td>매 루프</td></tr>
<tr><td><code>rShockSensorOperation</code></td><td>충격 센서(di17_Head1Shock, di19_Head2Shock) 감시, 자동모드+모터ON 시 에러 로깅</td><td>매 루프</td></tr>
<tr><td><code>rErrorTouch</code></td><td>stReact 배열로 아크 터치 에러 감지, 각 축별 홈복귀 신호 제어</td><td>매 루프</td></tr>
<tr><td><code>rDigtalSignalPC</code></td><td>PC 디지털 신호 처리 (현재 빈 프로시저, 향후 확장용)</td><td>매 루프</td></tr>
<tr><td><code>rMacroNo0_1_2</code></td><td>매크로 0/1/2번 용접 시퀀스 (PosHold 타이밍)</td><td>rUpdateWeldStatus에서 호출</td></tr>
<tr><td><code>rMacroNo3_4</code></td><td>매크로 3/4번 동시 용접 시퀀스 (양 로봇 ArcOn 동기)</td><td>rUpdateWeldStatus에서 호출</td></tr>
</table>

<p><strong>PlanA 대비 수정 사항:</strong></p>
<ul>
<li><code>rUpdateCurrentPosition()</code>: 갠트리 위치 읽기를 <code>CJointT(\TaskName:="T_Gantry")</code>에서 <code>CJointT(\TaskName:="T_Rob1")</code>로 변경.
PlanB에서는 갠트리가 Robot1의 외부축으로 통합되어 있어 <code>T_Rob1</code>의 extax에서 갠트리 위치를 읽어야 합니다.</li>
<li>나머지 모든 코드는 PlanA TASK9 원본을 그대로 유지하여 UI 호환성을 보장합니다.</li>
</ul>

<h3>4.2 TASK8/Head_Data.mod 변수 추가 <span class="tag tag-fix">T_Head 1건 해결</span></h3>

<pre>
! Head_Data.mod (Line 609~612)
! 기존 변수
PERS num nWarmUp_Speed:=10;       ! 워밍업 속도 (mm/s)
PERS num nWarmUp_Distance:=100;   ! 워밍업 거리 (mm)
PERS num nWarmUp_Count:=2;        ! 워밍업 목표 횟수

! 추가된 변수 (Line 612)
PERS num nWarmUpCycle:=0;         ! 현재 워밍업 진행 사이클 (UI 표시용)
</pre>

<p>초기값 0으로 선언하여 UI 바인딩 에러를 해결합니다.
향후 Head_MoveControl.mod의 워밍업 루프에서 실제 카운트를 업데이트하는 로직 추가가 필요합니다.</p>

<h3>4.3 TASK9 신규 생성 + T_Teaching 태스크 등록 <span class="tag tag-new">T_Teaching 4건 해결</span></h3>

<p><strong>4.3.1 디렉토리 구조 생성:</strong></p>
<pre>
RAPID/
  TASK9/                         &lt;-- 신규 생성
    PROGMOD/
      Teaching.mod               &lt;-- PlanA TASK10 기반 이식
    SYSMOD/
      user.sys                   &lt;-- 기본 시스템 모듈
</pre>

<p><strong>4.3.2 Teaching.mod 내용:</strong></p>
<pre>
MODULE Teaching
    ! UI-Required PERS Variables
    pers num nCurrentTargetVoltage{2};   ! UI Read: 현재 스텝 목표전압
    pers num nCurrentTargetWfs{2};       ! UI Read: 현재 스텝 목표 WFS
    PERS num nRealTimeVoltage{2};        ! UI Write: 운전자 전압 보정
    PERS num nRealTimeWfs{2};            ! UI Write: 운전자 WFS 보정

    ! Cross-task shared variables
    PERS targetdata Welds1{40};          ! Robot1 용접 데이터 40스텝
    PERS targetdata Welds2{40};          ! Robot2 용접 데이터 40스텝
    PERS num nRunningStep{2};            ! 현재 실행중인 용접 스텝 번호
    PERS bool bArc_On{2};               ! 아크 ON 상태 플래그

    PROC main()
        rCurrentTargetUpData;
    ENDPROC

    PROC rCurrentTargetUpData()
        ! Robot1: 용접전류 감지 또는 아크ON 시 목표값 계산
        IF (siLn1Current=1 AND siLn1TouchActive=0) OR bArc_On{1}=TRUE THEN
            nCurrentTargetVoltage{1} := Welds1{nRunningStep{1}}.voltage
                                        + nRealTimeVoltage{1};
            nCurrentTargetWfs{1} := Welds1{nRunningStep{1}}.wfs
                                    + nRealTimeWfs{1};
        ELSE
            nCurrentTargetVoltage{1} := 0;
            nCurrentTargetWfs{1} := 0;
        ENDIF

        ! Robot2: 동일 로직
        IF (siLn2Current=1 AND siLn2TouchActive=0) OR bArc_On{2}=TRUE THEN
            nCurrentTargetVoltage{2} := Welds2{nRunningStep{2}}.voltage
                                        + nRealTimeVoltage{2};
            nCurrentTargetWfs{2} := Welds2{nRunningStep{2}}.wfs
                                    + nRealTimeWfs{2};
        ELSE
            nCurrentTargetVoltage{2} := 0;
            nCurrentTargetWfs{2} := 0;
        ENDIF

        ! Teaching 포인트 설정 신호 처리
        IF pi53_SetTeachingPoint=1 reset po53_SetTeachingPoint;
    ENDPROC
ENDMODULE
</pre>

<p><strong>4.3.3 SYS.cfg 태스크 정의 추가:</strong></p>
<pre>
! SYSPAR/SYS.cfg - CAB_TASKS 섹션
! 기존
-Name "T_Head" -Type "NORMAL" -UseMechanicalUnitGroup "rob1"

! 추가 (T_Head 다음에 삽입)
-Name "T_Teaching" -TrustLevel "None" -UseMechanicalUnitGroup "rob1"
</pre>

<div class="info-box">
<strong>참고:</strong> PlanA에서 T_Teaching은 <code>Gantry</code> 그룹에 할당되어 있으나,
PlanB에는 별도 Gantry 그룹이 존재하지 않으므로 <code>rob1</code> 그룹에 할당합니다.
T_Teaching은 모션 태스크가 아니라 PERS 변수 계산만 수행하므로
Mechanical Unit Group 할당은 실행에 영향을 주지 않습니다.
</div>

<!-- ============================================ -->
<h2>5. 변경 파일 요약</h2>
<!-- ============================================ -->

<table>
<tr><th>#</th><th>파일 경로</th><th>변경 유형</th><th>변경 내용</th><th>해결 에러</th></tr>
<tr>
  <td>1</td>
  <td><code>RAPID/TASK7/PROGMOD/<br>Static.mod</code></td>
  <td><span class="tag tag-fix">교체</span></td>
  <td>PlanA TASK9 Static.mod 전체 코드 이식.<br>RECORD 4종 + PERS 50여개 + 프로시저 10개 + 함수 3개 포함.<br>T_Gantry -> T_Rob1 참조 변경 적용.</td>
  <td>MonRobs, CurrentTorque,<br>WeldDataStatus, WeldDataStatus2</td>
</tr>
<tr>
  <td>2</td>
  <td><code>RAPID/TASK8/PROGMOD/<br>Head_Data.mod</code></td>
  <td><span class="tag tag-fix">1행 추가</span></td>
  <td><code>PERS num nWarmUpCycle:=0;</code><br>(Line 612, nWarmUp_Count 다음)</td>
  <td>WarmUpPeriod</td>
</tr>
<tr>
  <td>3</td>
  <td><code>RAPID/TASK9/PROGMOD/<br>Teaching.mod</code></td>
  <td><span class="tag tag-new">신규 생성</span></td>
  <td>PlanA TASK10 Teaching.mod 기반 이식 (약 2.1KB).<br>targetdata RECORD + UI변수 4개 + rCurrentTargetUpData 프로시저.</td>
  <td>CurrentTargetVoltage, CurrentTargetWfs,<br>RealTimeVoltage, RealTimeWfs</td>
</tr>
<tr>
  <td>4</td>
  <td><code>RAPID/TASK9/SYSMOD/<br>user.sys</code></td>
  <td><span class="tag tag-new">신규 생성</span></td>
  <td>기본 시스템 모듈 (레지스터 변수, clock 선언)</td>
  <td>-</td>
</tr>
<tr>
  <td>5</td>
  <td><code>SYSPAR/SYS.cfg</code></td>
  <td><span class="tag tag-fix">1항 추가</span></td>
  <td>CAB_TASKS 섹션에 T_Teaching 태스크 정의 추가</td>
  <td>T_Teaching 태스크 인식</td>
</tr>
</table>

<!-- ============================================ -->
<h2>6. 크로스 태스크 데이터 흐름 (조치 후)</h2>
<!-- ============================================ -->

<p>조치 후 PlanB의 태스크간 데이터 공유 구조는 아래와 같습니다.
모든 공유 데이터는 <code>PERS</code> (Persistent) 변수로 선언되어 태스크 간 직접 참조가 가능합니다.</p>

<div class="diagram">
+----------------+     +----------------+     +------------------+
|  TASK1(T_ROB1) |     |  TASK2(T_ROB2) |     |  TASK8(T_Head)   |
|  MainModule    |     | Rob2_MainModule|     |  Head_MainModule |
|                |     |                |     |  Head_Data       |
|  - stCommand   |&lt;---&gt;|  - stCommand   |&lt;---&gt;|  - stCommand     |
|  - stReact{3}  |&lt;---&gt;|  - stReact{3}  |&lt;---&gt;|  - stReact{3}    |
|  - Welds1{40}  |----&gt;|  - Welds2{40}  |     |  - nWarmUpCycle  |
|  - nRunningStep|&lt;---&gt;|  - nRunningStep|     |  - nWarmUp_Count |
|  - bArc_On{2}  |&lt;---&gt;|  - bArc_On{2}  |     |                  |
+-------+--------+     +-------+--------+     +------------------+
        |                       |
        v                       v
+-------+--------+     +-------+--------+
| TASK7(T_BG)    |     | TASK9           |
| Static.mod     |     | (T_Teaching)    |
|                |     | Teaching.mod    |
| MonitorPosition|     |                 |
| nTorques{18}   |     | nCurrentTarget- |
| stWeld1        |     |   Voltage{2}   |
| stWeld2        |     | nCurrentTarget- |
|                |     |   Wfs{2}       |
| - Welds1/2{40} |     | nRealTime-     |
| - nRunningStep |     |   Voltage{2}   |
| - stCommand    |     | nRealTimeWfs{2}|
| - tWeld1/2     |     |                |
+----------------+     | - Welds1/2{40} |
        ^               | - nRunningStep |
        |               | - bArc_On{2}   |
        |               +-------+--------+
        |                       |
        v                       v
+-----------------------------------------------+
|              상위제어 UI (PC)                  |
|         ABB PC SDK로 PERS 변수 Read/Write     |
+-----------------------------------------------+
</div>

<!-- ============================================ -->
<h2>7. 적용 절차</h2>
<!-- ============================================ -->

<ol>
<li><strong>RobotStudio에서 가상 컨트롤러 중지</strong></li>
<li>변경된 5개 파일을 PlanB 백업 폴더에 복사
  <ul>
    <li><code>TASK7/PROGMOD/Static.mod</code> — 기존 파일 교체</li>
    <li><code>TASK8/PROGMOD/Head_Data.mod</code> — 기존 파일 교체</li>
    <li><code>TASK9/</code> 폴더 전체 — 신규 복사</li>
    <li><code>SYSPAR/SYS.cfg</code> — 기존 파일 교체</li>
  </ul>
</li>
<li><strong>컨트롤러 Warm Start</strong> (SYS.cfg 변경으로 인한 태스크 재인식 필수)</li>
<li>상위 UI 재시작 후 <code>RapidInitFailReport.txt</code> 에러 건수 0건 확인</li>
</ol>

<!-- ============================================ -->
<h2>8. 주의사항 및 후속 작업</h2>
<!-- ============================================ -->

<div class="warn-box">
<strong>즉시 확인 필요:</strong>
<ol style="margin:5px 0;">
<li><strong>EIO.cfg I/O 신호 정의 확인</strong> — Static.mod가 참조하는 I/O 신호가 PlanB의 EIO.cfg에 모두 정의되어 있어야 합니다.
  <ul>
    <li>입력: <code>siLn1Current</code>, <code>siLn1Voltage</code>, <code>siLn1TouchActive</code>, <code>siLn1Arc_Est</code>, <code>siLn2Current</code>, <code>siLn2Voltage</code>, <code>siLn2TouchActive</code>, <code>siLn2Arc_Est</code>, <code>di17_Head1Shock</code>, <code>di19_Head2Shock</code>, <code>co001_AutoMode</code>, <code>co002_PrgRun</code>, <code>co004_MotorOn</code>, <code>pi53_SetTeachingPoint</code></li>
    <li>출력: <code>cgo05_AxisX_Current</code>, <code>intMoveHome_Head</code>, <code>intMoveHome_RBT1</code>, <code>intMoveHome_RBT2</code>, <code>intMoveHome_Gantry</code>, <code>intTouch_1</code>, <code>intTouch_2</code>, <code>intReHoldGantry_1</code>, <code>intReHoldGantry_2</code>, <code>so_MoveG_PosHold</code>, <code>soLn1TouchActive</code>, <code>soLn2TouchActive</code>, <code>po03_Home</code>, <code>po08_RobotMoving</code>, <code>po53_SetTeachingPoint</code></li>
  </ul>
  미정의 신호가 있으면 RAPID 로드 시 에러가 발생합니다.
</li>
<li><strong>공유 PERS 변수 초기값</strong> — tWeld1, tWeld2 (용접 툴데이터), wobjWeldLine1, wobjWeldLine2, wobjRotCtr1, wobjRotCtr2 (작업좌표계)가 T_ROB1/T_ROB2에서 올바르게 정의되어 있어야 T_BG에서 참조 가능합니다.</li>
</ol>
</div>

<div class="info-box">
<strong>후속 작업 (디파인시스템 협의 필요):</strong>
<ul style="margin:5px 0;">
<li><strong>nWarmUpCycle 실제 카운트 연동:</strong> 현재 초기값 0으로만 선언되어 있으므로, Head_MoveControl.mod의 워밍업 루프 (<code>FOR i FROM 1 TO nWarmUp_Count*2 DO</code>) 내에서 <code>nWarmUpCycle := i;</code> 업데이트 로직을 추가해야 UI에서 실시간 진행률을 표시할 수 있습니다.</li>
<li><strong>Robot1/Robot2 토크 읽기 활성화:</strong> <code>rReadMotorTorque</code>에서 nTorques{1~12}는 주석 처리 상태입니다 (PlanA에서도 동일). 로봇 축 토크 모니터링이 필요한 경우 주석 해제 및 Mechanical Unit 이름 확인이 필요합니다.</li>
<li><strong>추가 에러 발생 가능성:</strong> 위 9건은 UI 초기화 단계에서 발견된 것으로, 실제 운용(용접 시작, 갠트리 이동 등) 시 추가 심볼 요구가 있을 수 있습니다. 초기 연동 후 전체 기능 테스트가 필요합니다.</li>
</ul>
</div>

<!-- ============================================ -->
<h2>9. PlanA &harr; PlanB 태스크 매핑 (최종)</h2>
<!-- ============================================ -->

<table>
<tr><th>TASK</th><th>PlanA 태스크</th><th>PlanA 역할</th><th>PlanB 태스크 (조치 후)</th><th>PlanB 역할</th></tr>
<tr><td>TASK1</td><td>T_ROB1</td><td>Robot1 용접 제어</td><td>T_ROB1</td><td>Robot1 + 갠트리 통합 제어</td></tr>
<tr><td>TASK2</td><td>T_ROB2</td><td>Robot2 용접 제어</td><td>T_ROB2</td><td>Robot2 용접 제어</td></tr>
<tr><td>TASK3~6</td><td>-</td><td>(시스템 예약)</td><td>-</td><td>(시스템 예약)</td></tr>
<tr><td>TASK7</td><td><strong>T_Gantry</strong></td><td>갠트리 독립 모션 제어</td><td><strong>T_BG</strong> <span class="tag tag-fix">복원</span></td><td>백그라운드 모니터링 (위치/토크/용접상태)</td></tr>
<tr><td>TASK8</td><td>T_Head</td><td>상위 커맨드 디스패처</td><td>T_Head <span class="tag tag-fix">+1변수</span></td><td>상위 커맨드 + nWarmUpCycle 추가</td></tr>
<tr><td>TASK9</td><td><strong>T_BG</strong></td><td>백그라운드 모니터링</td><td><strong>T_Teaching</strong> <span class="tag tag-new">신규</span></td><td>용접 파라미터 실시간 계산</td></tr>
<tr><td>TASK10</td><td>T_Teaching</td><td>용접 파라미터 계산</td><td>-</td><td>(해당 없음)</td></tr>
</table>

<div class="grey-box">
<strong>참고:</strong> PlanA와 PlanB의 TASK 폴더 번호가 다른 이유:<br>
PlanA는 TASK7에 T_Gantry(갠트리 모션)가 있어 T_BG가 TASK9, T_Teaching이 TASK10에 배치됩니다.<br>
PlanB는 T_Gantry가 없으므로 T_BG가 TASK7에, T_Teaching이 TASK9에 배치됩니다.<br>
그러나 <strong>UI는 태스크 폴더 번호가 아닌 태스크 이름(T_BG, T_Teaching)으로 변수를 접근</strong>하므로,
폴더 위치가 달라도 태스크 이름과 모듈/변수명이 일치하면 정상 동작합니다.
</div>

<div class="signature">
<p>
<strong>심태양</strong> | 에스피시스템스<br>
S25016 프로젝트 담당<br>
taeyang@spsystems.kr
</p>
</div>

</body>
</html>
