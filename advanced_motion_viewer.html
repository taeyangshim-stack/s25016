<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê³ ê¸‰ ìš©ì ‘ ëª¨ì…˜ ë·°ì–´ | XYZR ê° íŠ¸ë¦¬ + ë“€ì–¼ ë¡œë´‡</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3a8a 0%, #7c3aed 100%);
            padding: 15px;
            color: #333;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #1e3a8a 0%, #7c3aed 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .header p {
            font-size: 13px;
            opacity: 0.9;
        }

        .controls {
            background: #f8f9fa;
            padding: 15px;
            border-bottom: 2px solid #e0e0e0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group label {
            font-weight: 600;
            font-size: 13px;
            color: #555;
        }

        select, button, input[type="file"] {
            padding: 6px 12px;
            border: 2px solid #1e3a8a;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s;
        }

        button {
            background: #1e3a8a;
            color: white;
            font-weight: 600;
        }

        button:hover {
            background: #1e40af;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(30, 58, 138, 0.4);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        select {
            background: white;
        }

        .views-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            padding: 15px;
        }

        .view-box {
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
            background: #fafafa;
        }

        .view-header {
            background: #1e3a8a;
            color: white;
            padding: 8px;
            font-weight: 600;
            text-align: center;
            font-size: 14px;
        }

        canvas {
            display: block;
            width: 100%;
            background: white;
        }

        .timeline-container {
            padding: 15px;
            background: #f8f9fa;
            border-top: 2px solid #e0e0e0;
        }

        .timeline-label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #555;
            font-size: 14px;
        }

        .timeline-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
        }

        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #1e3a8a;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .timeline-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #1e3a8a;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            border: none;
        }

        .timeline-info {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 13px;
            color: #666;
        }

        .data-display {
            padding: 15px;
            background: white;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .data-item {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid #1e3a8a;
        }

        .data-item.warning {
            border-left-color: #ff9800;
            background: #fff3e0;
        }

        .data-item.danger {
            border-left-color: #f44336;
            background: #ffebee;
        }

        .data-item.info {
            border-left-color: #2196f3;
            background: #e3f2fd;
        }

        .data-item.success {
            border-left-color: #4caf50;
            background: #e8f5e9;
        }

        .data-item-label {
            font-size: 11px;
            color: #666;
            margin-bottom: 4px;
        }

        .data-item-value {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            min-width: 120px;
            text-align: right;
        }

        .legend {
            display: flex;
            gap: 15px;
            padding: 12px 15px;
            background: #f8f9fa;
            justify-content: center;
            flex-wrap: wrap;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        .file-drop-zone {
            padding: 30px;
            margin: 15px;
            border: 3px dashed #1e3a8a;
            border-radius: 12px;
            text-align: center;
            background: #f8f9fa;
            cursor: pointer;
            transition: all 0.3s;
        }

        .file-drop-zone:hover {
            background: #e8eaf6;
            border-color: #1e40af;
        }

        .file-drop-zone.drag-over {
            background: #e8eaf6;
            border-color: #1e40af;
            transform: scale(1.02);
        }

        .loading {
            text-align: center;
            padding: 30px;
            font-size: 16px;
            color: #666;
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 12px;
            margin: 15px;
            border-radius: 8px;
            border-left: 4px solid #c62828;
        }

        @media (max-width: 1400px) {
            .views-container {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 768px) {
            .views-container {
                grid-template-columns: 1fr;
            }

            .data-display {
                grid-template-columns: 1fr 1fr;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ­ ê³ ê¸‰ ìš©ì ‘ ëª¨ì…˜ ë·°ì–´ - XYZR ê° íŠ¸ë¦¬ + ë“€ì–¼ ë¡œë´‡ ì‹œìŠ¤í…œ</h1>
            <p>Të°” ì–‘ë©´ í•„ë › ìš©ì ‘ | Rì¶• íšŒì „ | ìœ„ë¹™ ëª¨ì…˜ | ë¹„ì „ í¬ì¸íŠ¸ | ë¡œë´‡ ìŠ¤ì™‘</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="caseSelect">ì¼€ì´ìŠ¤ ì„ íƒ:</label>
                <select id="caseSelect">
                    <option value="">-- CSV íŒŒì¼ì„ ë¡œë“œí•˜ì„¸ìš” --</option>
                </select>
            </div>

            <div class="control-group">
                <label for="fileInput">CSV ë¡œë“œ:</label>
                <input type="file" id="fileInput" accept=".csv" multiple>
            </div>

            <div class="control-group">
                <button id="playBtn" disabled>â–¶ ì¬ìƒ</button>
                <button id="pauseBtn" disabled>â¸ ì¼ì‹œì •ì§€</button>
                <button id="resetBtn" disabled>â® ì²˜ìŒìœ¼ë¡œ</button>
            </div>

            <div class="control-group">
                <label for="speedSelect">ì†ë„:</label>
                <select id="speedSelect">
                    <option value="0.25">0.25x</option>
                    <option value="0.5">0.5x</option>
                    <option value="1" selected>1x</option>
                    <option value="2">2x</option>
                    <option value="5">5x</option>
                </select>
            </div>

            <div class="control-group">
                <label><input type="checkbox" id="showVisionPoints" checked> ë¹„ì „ í¬ì¸íŠ¸</label>
                <label><input type="checkbox" id="showWeaving" checked> ìœ„ë¹™</label>
                <label><input type="checkbox" id="showTBar" checked> Të°” í˜•ìƒ</label>
                <label><input type="checkbox" id="showVectors" checked> í† ì¹˜ ë²¡í„°</label>
            </div>
        </div>

        <div id="dropZone" class="file-drop-zone">
            <h3>ğŸ“ CSV íŒŒì¼ì„ ì—¬ê¸°ì— ë“œë˜ê·¸ ì•¤ ë“œë¡­</h3>
            <p>ë˜ëŠ” ìœ„ì˜ "CSV ë¡œë“œ" ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”</p>
            <p style="margin-top: 10px; font-size: 11px; color: #666;">
                í•„ìˆ˜ ì»¬ëŸ¼: Time, Gantry_X/Y/Z/R, TCP1/2_X/Y/Z, TCP1/2_VX/VY/VZ, Weaving1/2, Motion_Type, Robot_Swap
            </p>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #f44336;"></div>
                <span>TCP1 (Robot1)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #2196f3;"></div>
                <span>TCP2 (Robot2)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4caf50;"></div>
                <span>Rì¶• ì¤‘ì‹¬</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff9800;"></div>
                <span>ë¡œë´‡ ë² ì´ìŠ¤ (Â±488mm)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #9c27b0;"></div>
                <span>ë¹„ì „ í¬ì¸íŠ¸</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #795548;"></div>
                <span>Të°” (12T ì›¹)</span>
            </div>
        </div>

        <div class="views-container">
            <div class="view-box">
                <div class="view-header">í‰ë©´ë„ (X-Y View) - íƒ‘ë·°</div>
                <canvas id="canvasXY" width="600" height="600"></canvas>
            </div>
            <div class="view-box">
                <div class="view-header">ì¸¡ë©´ë„ (X-Z View) - ì‚¬ì´ë“œë·°</div>
                <canvas id="canvasXZ" width="600" height="600"></canvas>
            </div>
            <div class="view-box">
                <div class="view-header">ì •ë©´ë„ (Y-Z View) - í”„ë¡ íŠ¸ë·°</div>
                <canvas id="canvasYZ" width="600" height="600"></canvas>
            </div>
        </div>

        <div class="timeline-container">
            <div class="timeline-label">íƒ€ì„ë¼ì¸</div>
            <input type="range" id="timelineSlider" class="timeline-slider" min="0" max="100" value="0" disabled>
            <div class="timeline-info">
                <span id="currentTime">00:00.0</span>
                <span id="motionTypeDisplay">-</span>
                <span id="totalTime">00:00.0</span>
            </div>
        </div>

        <div class="data-display" id="dataDisplay">
            <div class="data-item">
                <div class="data-item-label">ê° íŠ¸ë¦¬ X</div>
                <div class="data-item-value" id="gantryX">-</div>
            </div>
            <div class="data-item">
                <div class="data-item-label">ê° íŠ¸ë¦¬ Y</div>
                <div class="data-item-value" id="gantryY">-</div>
            </div>
            <div class="data-item">
                <div class="data-item-label">ê° íŠ¸ë¦¬ Z</div>
                <div class="data-item-value" id="gantryZ">-</div>
            </div>
            <div class="data-item info" id="gantryRItem">
                <div class="data-item-label">ê° íŠ¸ë¦¬ R (íšŒì „ê°)</div>
                <div class="data-item-value" id="gantryR">-</div>
            </div>
            <div class="data-item">
                <div class="data-item-label">TCP1 ìœ„ì¹˜</div>
                <div class="data-item-value" id="tcp1Pos">-</div>
            </div>
            <div class="data-item">
                <div class="data-item-label">TCP2 ìœ„ì¹˜</div>
                <div class="data-item-value" id="tcp2Pos">-</div>
            </div>
            <div class="data-item" id="distanceItem">
                <div class="data-item-label">í† ì¹˜ ê°„ ê±°ë¦¬</div>
                <div class="data-item-value" id="torchDistance">-</div>
            </div>
            <div class="data-item info">
                <div class="data-item-label">ëª¨ì…˜ íƒ€ì…</div>
                <div class="data-item-value" id="motionType">-</div>
            </div>
            <div class="data-item">
                <div class="data-item-label">ìœ„ë¹™ ì§„í­ (TCP1)</div>
                <div class="data-item-value" id="weaving1">-</div>
            </div>
            <div class="data-item">
                <div class="data-item-label">ìœ„ë¹™ ì§„í­ (TCP2)</div>
                <div class="data-item-value" id="weaving2">-</div>
            </div>
            <div class="data-item" id="robotSwapItem">
                <div class="data-item-label">ë¡œë´‡ ìŠ¤ì™‘</div>
                <div class="data-item-value" id="robotSwap">-</div>
            </div>
            <div class="data-item">
                <div class="data-item-label">ì‚¬ì´í´ íƒ€ì„</div>
                <div class="data-item-value" id="cycleTime">-</div>
            </div>
        </div>
    </div>

    <script>
        // ì „ì—­ ë³€ìˆ˜
        let motionData = {};
        let currentCase = null;
        let currentFrameIndex = 0;
        let isPlaying = false;
        let animationId = null;
        let playbackSpeed = 1.0;
        let lastUpdateTime = 0;

        // ì²´í¬ë°•ìŠ¤ ìƒíƒœ
        let showVisionPoints = true;
        let showWeaving = true;
        let showTBar = true;
        let showVectors = true;

        // DOM ìš”ì†Œ
        const fileInput = document.getElementById('fileInput');
        const caseSelect = document.getElementById('caseSelect');
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const speedSelect = document.getElementById('speedSelect');
        const timelineSlider = document.getElementById('timelineSlider');
        const dropZone = document.getElementById('dropZone');

        const canvasXY = document.getElementById('canvasXY');
        const canvasXZ = document.getElementById('canvasXZ');
        const canvasYZ = document.getElementById('canvasYZ');
        const ctxXY = canvasXY.getContext('2d');
        const ctxXZ = canvasXZ.getContext('2d');
        const ctxYZ = canvasYZ.getContext('2d');

        // ì²´í¬ë°•ìŠ¤ ì´ë²¤íŠ¸
        document.getElementById('showVisionPoints').addEventListener('change', (e) => {
            showVisionPoints = e.target.checked;
            updateDisplay();
        });
        document.getElementById('showWeaving').addEventListener('change', (e) => {
            showWeaving = e.target.checked;
            updateDisplay();
        });
        document.getElementById('showTBar').addEventListener('change', (e) => {
            showTBar = e.target.checked;
            updateDisplay();
        });
        document.getElementById('showVectors').addEventListener('change', (e) => {
            showVectors = e.target.checked;
            updateDisplay();
        });

        // ì¸ì¦ ì²´í¬
        function checkAuth() {
            const urlParams = new URLSearchParams(window.location.search);
            const authToken = urlParams.get('auth');
            const validToken = 'c49d872f-4bf0-4721-a5c6-5efb8fa9d8e1';

            if (authToken !== validToken) {
                document.body.innerHTML = '<div style="text-align:center; padding:100px;"><h1>â›” ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤</h1><p>ì˜¬ë°”ë¥¸ ì¸ì¦ í† í°ì´ í•„ìš”í•©ë‹ˆë‹¤.</p></div>';
                return false;
            }
            return true;
        }

        // CSV íŒŒì‹± - ë¹„ì „ ë°ì´í„°ë¡œë¶€í„° í”„ë ˆì„ ìë™ ìƒì„±
        function parseCSV(text, filename) {
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim());

            // ë¹„ì „ ë°ì´í„° ì½ê¸° (1í–‰ë§Œ)
            if (lines.length < 2) {
                console.error('âŒ CSV ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤');
                return;
            }

            const values = lines[1].split(',').map(v => v.trim());
            const visionData = {};
            headers.forEach((header, index) => {
                const val = values[index];
                visionData[header] = isNaN(val) || val === '' ? val : parseFloat(val);
            });

            // ë¹„ì „ 4í¬ì¸íŠ¸ ì¶”ì¶œ
            const S1 = { x: visionData.Vision_Start1_X, y: visionData.Vision_Start1_Y, z: visionData.Vision_Start1_Z };
            const E1 = { x: visionData.Vision_End1_X, y: visionData.Vision_End1_Y, z: visionData.Vision_End1_Z };
            const S2 = { x: visionData.Vision_Start2_X, y: visionData.Vision_Start2_Y, z: visionData.Vision_Start2_Z };
            const E2 = { x: visionData.Vision_End2_X, y: visionData.Vision_End2_Y, z: visionData.Vision_End2_Z };

            const weldingSpeed = visionData.Welding_Speed || 100; // mm/s
            const weavingAmplitude = visionData.Weaving_Amplitude || 6; // mm
            const approachHeight = visionData.Approach_Height || 1200; // mm
            const retractHeight = visionData.Retract_Height || 1200; // mm
            const frameInterval = visionData.Frame_Interval || 0.5; // ì´ˆ

            console.log('ğŸ“Š ë¹„ì „ ë°ì´í„° ë¡œë“œ:');
            console.log(`   Start1: (${S1.x}, ${S1.y}, ${S1.z})`);
            console.log(`   End1: (${E1.x}, ${E1.y}, ${E1.z})`);
            console.log(`   ìš©ì ‘ ì†ë„: ${weldingSpeed} mm/s`);
            console.log(`   í”„ë ˆì„ ê°„ê²©: ${frameInterval} s`);

            // T-bar ì†ì„± ê³„ì‚°
            const TBar_Center_X = (S1.x + E1.x + S2.x + E2.x) / 4;
            const TBar_Center_Y = (S1.y + E1.y + S2.y + E2.y) / 4;
            const TBar_Center_Z = (S1.z + E1.z + S2.z + E2.z) / 4;
            const webVec = { x: E1.x - S1.x, y: E1.y - S1.y };
            const webAngle = Math.atan2(webVec.y, webVec.x);
            const webAngleDeg = webAngle * 180 / Math.PI;
            const webThickness = Math.sqrt((S2.x-S1.x)**2 + (S2.y-S1.y)**2);

            // Rì¶• ê°ë„ = ì›¹ ê°ë„ (ê°™ìŒ!)
            // Rì¶• í”„ë ˆì„(ë¬¼ë¦¬ì  êµ¬ì¡°ë¬¼)ì€ í•­ìƒ ì›¹ê³¼ ìˆ˜ì§ = webAngle + 90Â°
            let rAxisAngle = webAngle;
            let rAxisAngleDeg = webAngleDeg;
            let robotSwap = false;

            // ë¡œë´‡ ìŠ¤ì™‘ ë¡œì§: ì›¹ > 90Â° ë˜ëŠ” ì›¹ < -90Â°
            if (webAngleDeg > 90) {
                rAxisAngle = webAngle - Math.PI;  // -180Â°
                rAxisAngleDeg = webAngleDeg - 180;
                robotSwap = true;
            } else if (webAngleDeg < -90) {
                rAxisAngle = webAngle + Math.PI;  // +180Â°
                rAxisAngleDeg = webAngleDeg + 180;
                robotSwap = true;
            }

            console.log('âœ… T-bar ìë™ ê³„ì‚°:');
            console.log(`   ì¤‘ì‹¬: (${TBar_Center_X.toFixed(1)}, ${TBar_Center_Y.toFixed(1)}, ${TBar_Center_Z.toFixed(1)})`);
            console.log(`   ì›¹ ê°ë„: ${webAngleDeg.toFixed(1)}Â°`);
            console.log(`   Rì¶• ê°ë„: ${rAxisAngleDeg.toFixed(1)}Â°`);
            console.log(`   ë¡œë´‡ ìŠ¤ì™‘: ${robotSwap ? 'âœ… (Robot1â†”2)' : 'âŒ'}`);
            console.log(`   ì›¹ ë‘ê»˜: ${webThickness.toFixed(1)}mm`);

            // ìš©ì ‘ ê±°ë¦¬ ë° ì‹œê°„ ê³„ì‚°
            const weldDistance = Math.sqrt((E1.x-S1.x)**2 + (E1.y-S1.y)**2);
            const weldTime = weldDistance / weldingSpeed;
            const numWeldFrames = Math.ceil(weldTime / frameInterval);

            console.log('â±ï¸ ìš©ì ‘ ê²½ë¡œ ê³„ì‚°:');
            console.log(`   ê±°ë¦¬: ${weldDistance.toFixed(1)}mm`);
            console.log(`   ì†Œìš” ì‹œê°„: ${weldTime.toFixed(1)}ì´ˆ`);
            console.log(`   í”„ë ˆì„ ìˆ˜: ${numWeldFrames}ê°œ`);

            // í”„ë ˆì„ ìƒì„±
            const frames = [];
            let currentTime = 0;
            let frameIndex = 0;

            // í—¬í¼ í•¨ìˆ˜: ì„ í˜• ë³´ê°„
            function lerp(start, end, ratio) {
                return start + (end - start) * ratio;
            }

            // í—¬í¼ í•¨ìˆ˜: ê° íŠ¸ë¦¬ ìœ„ì¹˜ ê³„ì‚°
            function calculateGantryPosition(tcp1, tcp2, rAngleDeg) {
                const rAngleRad = rAngleDeg * Math.PI / 180;
                const gantryX = (tcp1.x + tcp2.x) / 2;
                const gantryY = (tcp1.y + tcp2.y) / 2;
                return { x: gantryX, y: gantryY };
            }

            // 1. APPROACH í”„ë ˆì„ (ì ‘ê·¼)
            const approachDuration = 0.5; // 0.5ì´ˆ
            const numApproachFrames = Math.ceil(approachDuration / frameInterval);

            for (let i = 0; i <= numApproachFrames; i++) {
                const ratio = i / numApproachFrames;

                // ë¡œë´‡ ìŠ¤ì™‘ì— ë”°ë¥¸ TCP í• ë‹¹
                // ì •ìƒ: Robot1=aìš©ì ‘ì„ (S1), Robot2=bìš©ì ‘ì„ (S2)
                // ìŠ¤ì™‘: Robot1=bìš©ì ‘ì„ (S2), Robot2=aìš©ì ‘ì„ (S1)
                const tcp1_src = robotSwap ? S2 : S1;
                const tcp2_src = robotSwap ? S1 : S2;

                const tcp1 = { x: tcp1_src.x, y: tcp1_src.y, z: lerp(approachHeight, tcp1_src.z, ratio) };
                const tcp2 = { x: tcp2_src.x, y: tcp2_src.y, z: lerp(approachHeight, tcp2_src.z, ratio) };
                const gantry = calculateGantryPosition(tcp1, tcp2, rAxisAngleDeg);

                frames.push({
                    Time: currentTime,
                    Gantry_X: gantry.x,
                    Gantry_Y: gantry.y,
                    Gantry_Z: approachHeight,
                    Gantry_R: rAxisAngleDeg,
                    TCP1_X: tcp1.x, TCP1_Y: tcp1.y, TCP1_Z: tcp1.z,
                    TCP1_VX: Math.cos(webAngle), TCP1_VY: Math.sin(webAngle), TCP1_VZ: 0,
                    Weaving1: 0,
                    TCP2_X: tcp2.x, TCP2_Y: tcp2.y, TCP2_Z: tcp2.z,
                    TCP2_VX: Math.cos(webAngle), TCP2_VY: Math.sin(webAngle), TCP2_VZ: 0,
                    Weaving2: 0,
                    Motion_Type: 'APPROACH',
                    Robot_Swap: robotSwap ? 1 : 0,
                    TBar_Center_X, TBar_Center_Y, TBar_Center_Z,
                    TBar_Web_Angle: webAngle,
                    TBar_Web_Thickness: webThickness
                });
                currentTime += frameInterval;
            }

            // 2. WELD í”„ë ˆì„ (ìš©ì ‘, ìœ„ë¹™ ì ìš©)
            for (let i = 0; i <= numWeldFrames; i++) {
                const ratio = i / numWeldFrames;

                // ë¡œë´‡ ìŠ¤ì™‘ì— ë”°ë¥¸ TCP í• ë‹¹ ë° ì„ í˜• ë³´ê°„
                // ì •ìƒ: Robot1=S1â†’E1, Robot2=S2â†’E2
                // ìŠ¤ì™‘: Robot1=S2â†’E2, Robot2=S1â†’E1
                const tcp1_start = robotSwap ? S2 : S1;
                const tcp1_end = robotSwap ? E2 : E1;
                const tcp2_start = robotSwap ? S1 : S2;
                const tcp2_end = robotSwap ? E1 : E2;

                const tcp1_base = {
                    x: lerp(tcp1_start.x, tcp1_end.x, ratio),
                    y: lerp(tcp1_start.y, tcp1_end.y, ratio),
                    z: tcp1_start.z
                };
                const tcp2_base = {
                    x: lerp(tcp2_start.x, tcp2_end.x, ratio),
                    y: lerp(tcp2_start.y, tcp2_end.y, ratio),
                    z: tcp2_start.z
                };

                // ìœ„ë¹™ (ì •í˜„íŒŒ)
                const weavingPhase = (frameIndex * Math.PI / 2); // 90ë„ì”© ìœ„ìƒ ë³€í™”
                const weaving1 = Math.sin(weavingPhase) * weavingAmplitude;
                const weaving2 = -weaving1; // ë°˜ëŒ€ ìœ„ìƒ

                const tcp1 = { ...tcp1_base };
                const tcp2 = { ...tcp2_base };
                const gantry = calculateGantryPosition(tcp1, tcp2, rAxisAngleDeg);

                frames.push({
                    Time: currentTime,
                    Gantry_X: gantry.x,
                    Gantry_Y: gantry.y,
                    Gantry_Z: approachHeight,
                    Gantry_R: rAxisAngleDeg,
                    TCP1_X: tcp1.x, TCP1_Y: tcp1.y, TCP1_Z: tcp1.z,
                    TCP1_VX: Math.cos(webAngle), TCP1_VY: Math.sin(webAngle), TCP1_VZ: 0,
                    Weaving1: weaving1,
                    TCP2_X: tcp2.x, TCP2_Y: tcp2.y, TCP2_Z: tcp2.z,
                    TCP2_VX: Math.cos(webAngle), TCP2_VY: Math.sin(webAngle), TCP2_VZ: 0,
                    Weaving2: weaving2,
                    Motion_Type: 'WELD',
                    Robot_Swap: robotSwap ? 1 : 0,
                    TBar_Center_X, TBar_Center_Y, TBar_Center_Z,
                    TBar_Web_Angle: webAngle,
                    TBar_Web_Thickness: webThickness
                });
                currentTime += frameInterval;
                frameIndex++;
            }

            // 3. RETRACT í”„ë ˆì„ (í›„í‡´)
            const retractDuration = 0.5; // 0.5ì´ˆ
            const numRetractFrames = Math.ceil(retractDuration / frameInterval);

            for (let i = 0; i <= numRetractFrames; i++) {
                const ratio = i / numRetractFrames;

                // ë¡œë´‡ ìŠ¤ì™‘ì— ë”°ë¥¸ TCP í• ë‹¹
                const tcp1_src = robotSwap ? E2 : E1;
                const tcp2_src = robotSwap ? E1 : E2;

                const tcp1 = { x: tcp1_src.x, y: tcp1_src.y, z: lerp(tcp1_src.z, retractHeight, ratio) };
                const tcp2 = { x: tcp2_src.x, y: tcp2_src.y, z: lerp(tcp2_src.z, retractHeight, ratio) };
                const gantry = calculateGantryPosition(tcp1, tcp2, rAxisAngleDeg);

                frames.push({
                    Time: currentTime,
                    Gantry_X: gantry.x,
                    Gantry_Y: gantry.y,
                    Gantry_Z: retractHeight,
                    Gantry_R: rAxisAngleDeg,
                    TCP1_X: tcp1.x, TCP1_Y: tcp1.y, TCP1_Z: tcp1.z,
                    TCP1_VX: 0, TCP1_VY: 0, TCP1_VZ: 1,
                    Weaving1: 0,
                    TCP2_X: tcp2.x, TCP2_Y: tcp2.y, TCP2_Z: tcp2.z,
                    TCP2_VX: 0, TCP2_VY: 0, TCP2_VZ: 1,
                    Weaving2: 0,
                    Motion_Type: 'RETRACT',
                    Robot_Swap: robotSwap ? 1 : 0,
                    TBar_Center_X, TBar_Center_Y, TBar_Center_Z,
                    TBar_Web_Angle: webAngle,
                    TBar_Web_Thickness: webThickness
                });
                currentTime += frameInterval;
            }

            // 4. IDLE í”„ë ˆì„ (ëŒ€ê¸°)
            const tcp1_final = robotSwap ? E2 : E1;
            const tcp2_final = robotSwap ? E1 : E2;

            frames.push({
                Time: currentTime,
                Gantry_X: frames[frames.length-1].Gantry_X,
                Gantry_Y: frames[frames.length-1].Gantry_Y,
                Gantry_Z: retractHeight,
                Gantry_R: rAxisAngleDeg,
                TCP1_X: tcp1_final.x, TCP1_Y: tcp1_final.y, TCP1_Z: retractHeight,
                TCP1_VX: 0, TCP1_VY: 0, TCP1_VZ: 0,
                Weaving1: 0,
                TCP2_X: tcp2_final.x, TCP2_Y: tcp2_final.y, TCP2_Z: retractHeight,
                TCP2_VX: 0, TCP2_VY: 0, TCP2_VZ: 0,
                Weaving2: 0,
                Motion_Type: 'IDLE',
                Robot_Swap: robotSwap ? 1 : 0,
                TBar_Center_X, TBar_Center_Y, TBar_Center_Z,
                TBar_Web_Angle: webAngle,
                TBar_Web_Thickness: webThickness
            });

            console.log(`âœ… í”„ë ˆì„ ìƒì„± ì™„ë£Œ: ì´ ${frames.length}ê°œ`);
            console.log(`   APPROACH: ${numApproachFrames+1}ê°œ`);
            console.log(`   WELD: ${numWeldFrames+1}ê°œ`);
            console.log(`   RETRACT: ${numRetractFrames+1}ê°œ`);
            console.log(`   IDLE: 1ê°œ`);

            const caseName = filename.replace('.csv', '');
            motionData[caseName] = frames;

            const option = document.createElement('option');
            option.value = caseName;
            option.textContent = caseName;
            caseSelect.appendChild(option);

            return caseName;
        }

        // íŒŒì¼ ë¡œë“œ ì´ë²¤íŠ¸
        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            loadFiles(files);
        });

        // ë“œë˜ê·¸ ì•¤ ë“œë¡­
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            const files = Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.csv'));
            loadFiles(files);
        });

        dropZone.addEventListener('click', () => {
            fileInput.click();
        });

        function loadFiles(files) {
            if (files.length === 0) return;

            dropZone.innerHTML = '<div class="loading">ğŸ“‚ íŒŒì¼ ë¡œë”© ì¤‘...</div>';

            let loaded = 0;
            files.forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        parseCSV(e.target.result, file.name);
                        loaded++;

                        if (loaded === files.length) {
                            dropZone.style.display = 'none';
                            caseSelect.selectedIndex = 1;
                            caseSelect.dispatchEvent(new Event('change'));
                        }
                    } catch (error) {
                        dropZone.innerHTML = `<div class="error">âŒ ${file.name} ë¡œë“œ ì‹¤íŒ¨: ${error.message}</div>`;
                    }
                };
                reader.readAsText(file);
            });
        }

        // ì¼€ì´ìŠ¤ ì„ íƒ
        caseSelect.addEventListener('change', (e) => {
            const caseName = e.target.value;
            if (!caseName || !motionData[caseName]) return;

            currentCase = caseName;
            currentFrameIndex = 0;
            isPlaying = false;

            const frames = motionData[currentCase];
            timelineSlider.max = frames.length - 1;
            timelineSlider.value = 0;

            enableControls();
            updateDisplay();
        });

        function enableControls() {
            playBtn.disabled = false;
            pauseBtn.disabled = false;
            resetBtn.disabled = false;
            timelineSlider.disabled = false;
        }

        // ì¬ìƒ ì»¨íŠ¸ë¡¤
        playBtn.addEventListener('click', () => {
            isPlaying = true;
            lastUpdateTime = performance.now();
            animate();
        });

        pauseBtn.addEventListener('click', () => {
            isPlaying = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        });

        resetBtn.addEventListener('click', () => {
            isPlaying = false;
            currentFrameIndex = 0;
            timelineSlider.value = 0;
            updateDisplay();
        });

        speedSelect.addEventListener('change', (e) => {
            playbackSpeed = parseFloat(e.target.value);
        });

        timelineSlider.addEventListener('input', (e) => {
            currentFrameIndex = parseInt(e.target.value);
            updateDisplay();
        });

        // ì• ë‹ˆë©”ì´ì…˜
        function animate(currentTime) {
            if (!isPlaying) return;

            const deltaTime = currentTime - lastUpdateTime;
            const frames = motionData[currentCase];

            const frameInterval = 500 / playbackSpeed;

            if (deltaTime >= frameInterval) {
                currentFrameIndex++;

                if (currentFrameIndex >= frames.length) {
                    currentFrameIndex = frames.length - 1;
                    isPlaying = false;
                    return;
                }

                timelineSlider.value = currentFrameIndex;
                updateDisplay();
                lastUpdateTime = currentTime;
            }

            animationId = requestAnimationFrame(animate);
        }

        // í™”ë©´ ì—…ë°ì´íŠ¸
        function updateDisplay() {
            if (!currentCase || !motionData[currentCase]) return;

            const frames = motionData[currentCase];
            const frame = frames[currentFrameIndex];

            // ë°ì´í„° í‘œì‹œ
            document.getElementById('gantryX').textContent = `${frame.Gantry_X.toFixed(1)} mm`;
            document.getElementById('gantryY').textContent = `${frame.Gantry_Y.toFixed(1)} mm`;
            document.getElementById('gantryZ').textContent = `${frame.Gantry_Z.toFixed(1)} mm`;
            document.getElementById('gantryR').textContent = `${frame.Gantry_R.toFixed(1)}Â°`;

            // Rì¶• ê²½ê³ 
            const gantryRItem = document.getElementById('gantryRItem');
            gantryRItem.className = 'data-item info';
            if (Math.abs(frame.Gantry_R) > 100) {
                gantryRItem.classList.add('danger');
            } else if (Math.abs(frame.Gantry_R) > 90) {
                gantryRItem.classList.add('warning');
            }

            document.getElementById('tcp1Pos').textContent =
                `(${frame.TCP1_X.toFixed(1)}, ${frame.TCP1_Y.toFixed(1)}, ${frame.TCP1_Z.toFixed(1)})`;
            document.getElementById('tcp2Pos').textContent =
                `(${frame.TCP2_X.toFixed(1)}, ${frame.TCP2_Y.toFixed(1)}, ${frame.TCP2_Z.toFixed(1)})`;

            // í† ì¹˜ ê°„ ê±°ë¦¬ ê³„ì‚°
            const dx = frame.TCP2_X - frame.TCP1_X;
            const dy = frame.TCP2_Y - frame.TCP1_Y;
            const dz = frame.TCP2_Z - frame.TCP1_Z;
            const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);

            const distanceItem = document.getElementById('distanceItem');
            distanceItem.className = 'data-item';
            if (distance < 300) {
                distanceItem.classList.add('danger');
            } else if (distance < 500) {
                distanceItem.classList.add('warning');
            }
            document.getElementById('torchDistance').textContent = `${distance.toFixed(1)} mm`;

            // ëª¨ì…˜ íƒ€ì…
            const motionType = frame.Motion_Type || 'IDLE';
            document.getElementById('motionType').textContent = motionType;
            document.getElementById('motionTypeDisplay').textContent = motionType;

            // ìœ„ë¹™
            document.getElementById('weaving1').textContent = `${(frame.Weaving1 || 0).toFixed(1)} mm`;
            document.getElementById('weaving2').textContent = `${(frame.Weaving2 || 0).toFixed(1)} mm`;

            // ë¡œë´‡ ìŠ¤ì™‘
            const robotSwap = frame.Robot_Swap || 0;
            const robotSwapItem = document.getElementById('robotSwapItem');
            robotSwapItem.className = 'data-item';
            if (robotSwap === 1) {
                robotSwapItem.classList.add('warning');
                document.getElementById('robotSwap').textContent = 'âš ï¸ SWAP';
            } else {
                robotSwapItem.classList.add('success');
                document.getElementById('robotSwap').textContent = 'âœ“ ì •ìƒ';
            }

            // ì‹œê°„ í‘œì‹œ
            document.getElementById('currentTime').textContent = formatTime(frame.Time);
            document.getElementById('totalTime').textContent = formatTime(frames[frames.length - 1].Time);
            document.getElementById('cycleTime').textContent = formatTime(frames[frames.length - 1].Time);

            // ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸°
            drawXYView(frames, currentFrameIndex);
            drawXZView(frames, currentFrameIndex);
            drawYZView(frames, currentFrameIndex);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = (seconds % 60).toFixed(1);
            return `${mins.toString().padStart(2, '0')}:${secs.padStart(4, '0')}`;
        }

        // XY í‰ë©´ë„ ê·¸ë¦¬ê¸°
        function drawXYView(frames, currentIndex) {
            const width = canvasXY.width;
            const height = canvasXY.height;

            ctxXY.clearRect(0, 0, width, height);

            // ë¡œë´‡ ë² ì´ìŠ¤ ìœ„ì¹˜ë¥¼ í¬í•¨í•œ ë²”ìœ„ ê³„ì‚°
            const allX = frames.flatMap(f => {
                const rAngle = f.Gantry_R * Math.PI / 180;
                const rFrameAngle = rAngle + Math.PI / 2;  // Rì¶• í”„ë ˆì„ ë°©í–¥
                const r1X = f.Gantry_X + 488 * Math.cos(rFrameAngle);
                const r2X = f.Gantry_X - 488 * Math.cos(rFrameAngle);
                return [f.Gantry_X, f.TCP1_X, f.TCP2_X, r1X, r2X];
            });
            const allY = frames.flatMap(f => {
                const rAngle = f.Gantry_R * Math.PI / 180;
                const rFrameAngle = rAngle + Math.PI / 2;  // Rì¶• í”„ë ˆì„ ë°©í–¥
                const r1Y = f.Gantry_Y + 488 * Math.sin(rFrameAngle);
                const r2Y = f.Gantry_Y - 488 * Math.sin(rFrameAngle);
                return [f.Gantry_Y, f.TCP1_Y, f.TCP2_Y, r1Y, r2Y];
            });
            const minX = Math.min(...allX) - 200;
            const maxX = Math.max(...allX) + 200;
            const minY = Math.min(...allY) - 200;
            const maxY = Math.max(...allY) + 200;

            const margin = 50;
            const scaleX = (width - 2 * margin) / (maxX - minX);
            const scaleY = (height - 2 * margin) / (maxY - minY);
            const scale = Math.min(scaleX, scaleY);

            function toCanvasX(x) {
                return margin + (x - minX) * scale;
            }

            function toCanvasY(y) {
                return height - margin - (y - minY) * scale;
            }

            // ê·¸ë¦¬ë“œ
            ctxXY.strokeStyle = '#e0e0e0';
            ctxXY.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = margin + (width - 2 * margin) * i / 10;
                const y = margin + (height - 2 * margin) * i / 10;
                ctxXY.beginPath();
                ctxXY.moveTo(x, margin);
                ctxXY.lineTo(x, height - margin);
                ctxXY.stroke();
                ctxXY.beginPath();
                ctxXY.moveTo(margin, y);
                ctxXY.lineTo(width - margin, y);
                ctxXY.stroke();
            }

            const currentFrame = frames[currentIndex];

            // Të°” í˜•ìƒ (12T ë‘ê»˜, ê³ ì • ìœ„ì¹˜)
            if (showTBar) {
                // Të°”ëŠ” ê³ ì • ìœ„ì¹˜ (ì²« í”„ë ˆì„ì—ì„œ ê°€ì ¸ì˜´)
                const tbarX = frames[0].TBar_Center_X || 1000;
                const tbarY = frames[0].TBar_Center_Y || 500;

                // ì›¹ ë°©í–¥: ë¹„ì „ìœ¼ë¡œë¶€í„° ìë™ ê³„ì‚°ëœ ê°’ ì‚¬ìš©, ì—†ìœ¼ë©´ Rì¶•-90Â° ì‚¬ìš©
                let webAngle;
                if (frames[0].TBar_Web_Angle !== undefined) {
                    webAngle = frames[0].TBar_Web_Angle; // ìë™ ê³„ì‚°ëœ ì›¹ ê°ë„
                } else {
                    const rAngle = frames[0].Gantry_R * Math.PI / 180;
                    webAngle = rAngle - Math.PI / 2; // í´ë°±: Rì¶• - 90Â°
                }

                // Të°” ì›¹ (ì„¸ë¡œ) - 12mm ë‘ê»˜
                const webThickness = 12;
                const webLength = 1000;  // 1000mm ê¸¸ì´

                ctxXY.fillStyle = 'rgba(121, 85, 72, 0.3)';
                ctxXY.strokeStyle = '#795548';
                ctxXY.lineWidth = 2;

                // Të°” ì›¹ ë°©í–¥ìœ¼ë¡œ íšŒì „
                ctxXY.save();
                ctxXY.translate(toCanvasX(tbarX), toCanvasY(tbarY));
                ctxXY.rotate(-webAngle);

                // ì›¹ ì¤‘ì‹¬ì„ ì—ì„œ Â±6mm
                ctxXY.fillRect(-webLength/2 * scale, -webThickness/2 * scale, webLength * scale, webThickness * scale);
                ctxXY.strokeRect(-webLength/2 * scale, -webThickness/2 * scale, webLength * scale, webThickness * scale);

                ctxXY.restore();
            }

            // Rì¶• ì¤‘ì‹¬ (ê° íŠ¸ë¦¬ ì¤‘ì‹¬)
            ctxXY.fillStyle = '#4caf50';
            ctxXY.beginPath();
            ctxXY.arc(toCanvasX(currentFrame.Gantry_X), toCanvasY(currentFrame.Gantry_Y), 8, 0, Math.PI * 2);
            ctxXY.fill();

            // ë¡œë´‡ ë² ì´ìŠ¤ ìœ„ì¹˜ (Rì¶• ì¤‘ì‹¬ì—ì„œ Â±488mm)
            // Rì¶• í”„ë ˆì„ì€ ì›¹ì— ìˆ˜ì§ = Gantry_R + 90Â°
            const rAngle = currentFrame.Gantry_R * Math.PI / 180;
            const rFrameAngle = rAngle + Math.PI / 2;  // Rì¶• í”„ë ˆì„ ë°©í–¥
            const robot1BaseX = currentFrame.Gantry_X + 488 * Math.cos(rFrameAngle);
            const robot1BaseY = currentFrame.Gantry_Y + 488 * Math.sin(rFrameAngle);
            const robot2BaseX = currentFrame.Gantry_X - 488 * Math.cos(rFrameAngle);
            const robot2BaseY = currentFrame.Gantry_Y - 488 * Math.sin(rFrameAngle);

            // ë°”ë”” í”„ë ˆì„ (ë‘ ë¡œë´‡ì„ ì—°ê²°í•˜ëŠ” ë°”)
            ctxXY.strokeStyle = '#ff6f00';
            ctxXY.lineWidth = 8;
            ctxXY.beginPath();
            ctxXY.moveTo(toCanvasX(robot1BaseX), toCanvasY(robot1BaseY));
            ctxXY.lineTo(toCanvasX(robot2BaseX), toCanvasY(robot2BaseY));
            ctxXY.stroke();

            // ë¡œë´‡ ë² ì´ìŠ¤ ì 
            ctxXY.fillStyle = '#ff9800';
            ctxXY.beginPath();
            ctxXY.arc(toCanvasX(robot1BaseX), toCanvasY(robot1BaseY), 8, 0, Math.PI * 2);
            ctxXY.fill();

            // ë¡œë´‡ ë² ì´ìŠ¤ ë¼ë²¨
            ctxXY.fillStyle = '#333';
            ctxXY.font = 'bold 11px Arial';
            ctxXY.fillText('R1', toCanvasX(robot1BaseX) + 12, toCanvasY(robot1BaseY) + 4);

            ctxXY.fillStyle = '#ff9800';
            ctxXY.beginPath();
            ctxXY.arc(toCanvasX(robot2BaseX), toCanvasY(robot2BaseY), 8, 0, Math.PI * 2);
            ctxXY.fill();

            ctxXY.fillStyle = '#333';
            ctxXY.fillText('R2', toCanvasX(robot2BaseX) + 12, toCanvasY(robot2BaseY) + 4);

            // ê²½ë¡œ ê·¸ë¦¬ê¸° (TCP1 - ë¹¨ê°•)
            ctxXY.strokeStyle = '#f44336';
            ctxXY.lineWidth = 2;
            ctxXY.beginPath();
            for (let i = 0; i <= currentIndex; i++) {
                const x = toCanvasX(frames[i].TCP1_X);
                const y = toCanvasY(frames[i].TCP1_Y);
                if (i === 0) {
                    ctxXY.moveTo(x, y);
                } else {
                    ctxXY.lineTo(x, y);
                }
            }
            ctxXY.stroke();

            // ê²½ë¡œ ê·¸ë¦¬ê¸° (TCP2 - íŒŒë‘)
            ctxXY.strokeStyle = '#2196f3';
            ctxXY.lineWidth = 2;
            ctxXY.beginPath();
            for (let i = 0; i <= currentIndex; i++) {
                const x = toCanvasX(frames[i].TCP2_X);
                const y = toCanvasY(frames[i].TCP2_Y);
                if (i === 0) {
                    ctxXY.moveTo(x, y);
                } else {
                    ctxXY.lineTo(x, y);
                }
            }
            ctxXY.stroke();

            // ìœ„ë¹™ í‘œì‹œ
            if (showWeaving && (currentFrame.Weaving1 !== 0 || currentFrame.Weaving2 !== 0)) {
                ctxXY.strokeStyle = 'rgba(244, 67, 54, 0.3)';
                ctxXY.lineWidth = Math.abs(currentFrame.Weaving1) * scale * 2;
                ctxXY.beginPath();
                ctxXY.arc(toCanvasX(currentFrame.TCP1_X), toCanvasY(currentFrame.TCP1_Y),
                         Math.abs(currentFrame.Weaving1) * scale, 0, Math.PI * 2);
                ctxXY.stroke();

                ctxXY.strokeStyle = 'rgba(33, 150, 243, 0.3)';
                ctxXY.lineWidth = Math.abs(currentFrame.Weaving2) * scale * 2;
                ctxXY.beginPath();
                ctxXY.arc(toCanvasX(currentFrame.TCP2_X), toCanvasY(currentFrame.TCP2_Y),
                         Math.abs(currentFrame.Weaving2) * scale, 0, Math.PI * 2);
                ctxXY.stroke();
            }

            // TCP1 (ë¹¨ê°•)
            ctxXY.fillStyle = '#f44336';
            ctxXY.beginPath();
            ctxXY.arc(toCanvasX(currentFrame.TCP1_X), toCanvasY(currentFrame.TCP1_Y), 10, 0, Math.PI * 2);
            ctxXY.fill();

            // TCP2 (íŒŒë‘)
            ctxXY.fillStyle = '#2196f3';
            ctxXY.beginPath();
            ctxXY.arc(toCanvasX(currentFrame.TCP2_X), toCanvasY(currentFrame.TCP2_Y), 10, 0, Math.PI * 2);
            ctxXY.fill();

            // í† ì¹˜ ë°©í–¥ ë²¡í„°
            if (showVectors && currentFrame.TCP1_VX !== undefined) {
                const vectorLen = 50 * scale;

                // TCP1 ë²¡í„°
                ctxXY.strokeStyle = '#f44336';
                ctxXY.lineWidth = 3;
                ctxXY.beginPath();
                ctxXY.moveTo(toCanvasX(currentFrame.TCP1_X), toCanvasY(currentFrame.TCP1_Y));
                ctxXY.lineTo(
                    toCanvasX(currentFrame.TCP1_X + currentFrame.TCP1_VX * 50),
                    toCanvasY(currentFrame.TCP1_Y + currentFrame.TCP1_VY * 50)
                );
                ctxXY.stroke();

                // TCP2 ë²¡í„°
                ctxXY.strokeStyle = '#2196f3';
                ctxXY.beginPath();
                ctxXY.moveTo(toCanvasX(currentFrame.TCP2_X), toCanvasY(currentFrame.TCP2_Y));
                ctxXY.lineTo(
                    toCanvasX(currentFrame.TCP2_X + currentFrame.TCP2_VX * 50),
                    toCanvasY(currentFrame.TCP2_Y + currentFrame.TCP2_VY * 50)
                );
                ctxXY.stroke();
            }

            // ë¹„ì „ í¬ì¸íŠ¸ (ì²« í”„ë ˆì„ì—ì„œ ì¶”ì¶œ)
            if (showVisionPoints && currentIndex === 0) {
                const firstFrame = frames[0];
                const lastFrame = frames[frames.length - 1];

                ctxXY.fillStyle = '#9c27b0';
                ctxXY.font = '10px Arial';

                // Start1, End1
                ctxXY.beginPath();
                ctxXY.arc(toCanvasX(firstFrame.TCP1_X), toCanvasY(firstFrame.TCP1_Y), 8, 0, Math.PI * 2);
                ctxXY.fill();
                ctxXY.fillText('S1', toCanvasX(firstFrame.TCP1_X) + 12, toCanvasY(firstFrame.TCP1_Y));

                ctxXY.beginPath();
                ctxXY.arc(toCanvasX(lastFrame.TCP1_X), toCanvasY(lastFrame.TCP1_Y), 8, 0, Math.PI * 2);
                ctxXY.fill();
                ctxXY.fillText('E1', toCanvasX(lastFrame.TCP1_X) + 12, toCanvasY(lastFrame.TCP1_Y));

                // Start2, End2
                ctxXY.beginPath();
                ctxXY.arc(toCanvasX(firstFrame.TCP2_X), toCanvasY(firstFrame.TCP2_Y), 8, 0, Math.PI * 2);
                ctxXY.fill();
                ctxXY.fillText('S2', toCanvasX(firstFrame.TCP2_X) + 12, toCanvasY(firstFrame.TCP2_Y));

                ctxXY.beginPath();
                ctxXY.arc(toCanvasX(lastFrame.TCP2_X), toCanvasY(lastFrame.TCP2_Y), 8, 0, Math.PI * 2);
                ctxXY.fill();
                ctxXY.fillText('E2', toCanvasX(lastFrame.TCP2_X) + 12, toCanvasY(lastFrame.TCP2_Y));
            }

            // ì¶• ë¼ë²¨
            ctxXY.fillStyle = '#333';
            ctxXY.font = '14px Arial';
            ctxXY.fillText('X â†’', width - 40, height - 10);
            ctxXY.fillText('Y â†‘', 10, 20);
        }

        // XZ ì¸¡ë©´ë„ ê·¸ë¦¬ê¸°
        function drawXZView(frames, currentIndex) {
            const width = canvasXZ.width;
            const height = canvasXZ.height;

            ctxXZ.clearRect(0, 0, width, height);

            // ë¡œë´‡ ë² ì´ìŠ¤ ë° T-barë¥¼ í¬í•¨í•œ ë²”ìœ„ ê³„ì‚°
            const allX = frames.flatMap(f => {
                const rAngle = f.Gantry_R * Math.PI / 180;
                const rFrameAngle = rAngle + Math.PI / 2;  // Rì¶• í”„ë ˆì„ ë°©í–¥
                const r1X = f.Gantry_X + 488 * Math.cos(rFrameAngle);
                const r2X = f.Gantry_X - 488 * Math.cos(rFrameAngle);
                return [f.Gantry_X, f.TCP1_X, f.TCP2_X, r1X, r2X];
            });
            const allZ = frames.flatMap(f => [f.Gantry_Z, f.TCP1_Z, f.TCP2_Z, 0, 220]);
            const minX = Math.min(...allX) - 200;
            const maxX = Math.max(...allX) + 200;
            const minZ = Math.min(...allZ) - 50;
            const maxZ = Math.max(...allZ) + 100;

            const margin = 50;
            const scaleX = (width - 2 * margin) / (maxX - minX);
            const scaleZ = (height - 2 * margin) / (maxZ - minZ);
            const scale = Math.min(scaleX, scaleZ);

            function toCanvasX(x) {
                return margin + (x - minX) * scale;
            }

            function toCanvasZ(z) {
                return height - margin - (z - minZ) * scale;
            }

            // ê·¸ë¦¬ë“œ
            ctxXZ.strokeStyle = '#e0e0e0';
            ctxXZ.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = margin + (width - 2 * margin) * i / 10;
                const z = margin + (height - 2 * margin) * i / 10;
                ctxXZ.beginPath();
                ctxXZ.moveTo(x, margin);
                ctxXZ.lineTo(x, height - margin);
                ctxXZ.stroke();
                ctxXZ.beginPath();
                ctxXZ.moveTo(margin, z);
                ctxXZ.lineTo(width - margin, z);
                ctxXZ.stroke();
            }

            const currentFrame = frames[currentIndex];

            // Të°” í˜•ìƒ (ì¸¡ë©´: í‰íŒ í•˜ë©´=Z0(ë°”ë‹¥), í‰íŒ ìƒë©´=Z20(ìš©ì ‘ì„ ), ì›¹=Z20~220)
            if (showTBar) {
                // Të°”ëŠ” ê³ ì • ìœ„ì¹˜ (ì²« í”„ë ˆì„ì—ì„œ ê°€ì ¸ì˜´)
                const tbarX = frames[0].TBar_Center_X || 1000;
                const tbarZ = frames[0].TBar_Center_Z || 0;  // ë°”ë‹¥ë©´

                // ì›¹ ë°©í–¥: ë¹„ì „ìœ¼ë¡œë¶€í„° ìë™ ê³„ì‚°ëœ ê°’ ì‚¬ìš©, ì—†ìœ¼ë©´ Rì¶•-90Â° ì‚¬ìš©
                let webAngle;
                if (frames[0].TBar_Web_Angle !== undefined) {
                    webAngle = frames[0].TBar_Web_Angle; // ìë™ ê³„ì‚°ëœ ì›¹ ê°ë„
                } else {
                    const rAngle = frames[0].Gantry_R * Math.PI / 180;
                    webAngle = rAngle - Math.PI / 2; // í´ë°±: Rì¶• - 90Â°
                }

                const webLength = 1000;  // ì›¹ ê¸¸ì´ 1000mm
                const plateThickness = 20;  // í‰íŒ ë‘ê»˜
                const webHeight = 200;   // ì›¹ ë†’ì´ 200mm

                ctxXZ.fillStyle = 'rgba(121, 85, 72, 0.3)';
                ctxXZ.strokeStyle = '#795548';
                ctxXZ.lineWidth = 2;

                // XZ ì¸¡ë©´ë„ì—ì„œ ì›¹ì˜ Xë°©í–¥ íˆ¬ì˜ ê¸¸ì´: |cos(webAngle)| * webLength
                const projectedLength = webLength * Math.abs(Math.cos(webAngle));
                console.log(`ğŸ” XZ ì¸¡ë©´ë„ - webAngle: ${(webAngle * 180 / Math.PI).toFixed(1)}Â°, projectedLength: ${projectedLength.toFixed(1)}mm`);

                // í‰íŒ (Z=0~20, ë°”ë‹¥ì— ë†“ì„)
                ctxXZ.fillRect(toCanvasX(tbarX - projectedLength/2), toCanvasZ(tbarZ + plateThickness),
                              Math.abs(projectedLength * scale), plateThickness * scale);
                ctxXZ.strokeRect(toCanvasX(tbarX - projectedLength/2), toCanvasZ(tbarZ + plateThickness),
                                Math.abs(projectedLength * scale), plateThickness * scale);

                // ì›¹ (Z=20~220, í‰íŒ ìƒë©´ì—ì„œ ìœ„ë¡œ)
                ctxXZ.fillRect(toCanvasX(tbarX - projectedLength/2), toCanvasZ(tbarZ + plateThickness + webHeight),
                              Math.abs(projectedLength * scale), webHeight * scale);
                ctxXZ.strokeRect(toCanvasX(tbarX - projectedLength/2), toCanvasZ(tbarZ + plateThickness + webHeight),
                                Math.abs(projectedLength * scale), webHeight * scale);
            }

            // ê° íŠ¸ë¦¬ ì¤‘ì‹¬ (ë…¹ìƒ‰)
            ctxXZ.fillStyle = '#4caf50';
            ctxXZ.beginPath();
            ctxXZ.arc(toCanvasX(currentFrame.Gantry_X), toCanvasZ(currentFrame.Gantry_Z), 8, 0, Math.PI * 2);
            ctxXZ.fill();

            // ë¡œë´‡ ë² ì´ìŠ¤ ìœ„ì¹˜ (Xì¶• íˆ¬ì˜)
            // Rì¶• í”„ë ˆì„ = Gantry_R + 90Â°
            const rAngle = currentFrame.Gantry_R * Math.PI / 180;
            const rFrameAngle = rAngle + Math.PI / 2;
            const robot1BaseX = currentFrame.Gantry_X + 488 * Math.cos(rFrameAngle);
            const robot2BaseX = currentFrame.Gantry_X - 488 * Math.cos(rFrameAngle);

            // ë°”ë”” í”„ë ˆì„ (ë‘ ë¡œë´‡ ì—°ê²°í•˜ëŠ” ë°”)
            ctxXZ.strokeStyle = '#ff6f00';
            ctxXZ.lineWidth = 8;
            ctxXZ.beginPath();
            ctxXZ.moveTo(toCanvasX(robot1BaseX), toCanvasZ(currentFrame.Gantry_Z));
            ctxXZ.lineTo(toCanvasX(robot2BaseX), toCanvasZ(currentFrame.Gantry_Z));
            ctxXZ.stroke();

            // ë¡œë´‡ ë² ì´ìŠ¤ (ì£¼í™©ìƒ‰ ì )
            ctxXZ.fillStyle = '#ff9800';
            ctxXZ.beginPath();
            ctxXZ.arc(toCanvasX(robot1BaseX), toCanvasZ(currentFrame.Gantry_Z), 6, 0, Math.PI * 2);
            ctxXZ.fill();
            ctxXZ.beginPath();
            ctxXZ.arc(toCanvasX(robot2BaseX), toCanvasZ(currentFrame.Gantry_Z), 6, 0, Math.PI * 2);
            ctxXZ.fill();

            // ë¡œë´‡ ë² ì´ìŠ¤ ë¼ë²¨
            ctxXZ.fillStyle = '#ff6f00';
            ctxXZ.font = 'bold 12px Arial';
            ctxXZ.fillText('R1', toCanvasX(robot1BaseX) + 10, toCanvasZ(currentFrame.Gantry_Z) - 10);
            ctxXZ.fillText('R2', toCanvasX(robot2BaseX) + 10, toCanvasZ(currentFrame.Gantry_Z) - 10);

            // ê²½ë¡œ ê·¸ë¦¬ê¸° (TCP1 - ë¹¨ê°•)
            ctxXZ.strokeStyle = '#f44336';
            ctxXZ.lineWidth = 2;
            ctxXZ.beginPath();
            for (let i = 0; i <= currentIndex; i++) {
                const x = toCanvasX(frames[i].TCP1_X);
                const z = toCanvasZ(frames[i].TCP1_Z);
                if (i === 0) {
                    ctxXZ.moveTo(x, z);
                } else {
                    ctxXZ.lineTo(x, z);
                }
            }
            ctxXZ.stroke();

            // ê²½ë¡œ ê·¸ë¦¬ê¸° (TCP2 - íŒŒë‘)
            ctxXZ.strokeStyle = '#2196f3';
            ctxXZ.lineWidth = 2;
            ctxXZ.beginPath();
            for (let i = 0; i <= currentIndex; i++) {
                const x = toCanvasX(frames[i].TCP2_X);
                const z = toCanvasZ(frames[i].TCP2_Z);
                if (i === 0) {
                    ctxXZ.moveTo(x, z);
                } else {
                    ctxXZ.lineTo(x, z);
                }
            }
            ctxXZ.stroke();

            // TCP1 (ë¹¨ê°•)
            ctxXZ.fillStyle = '#f44336';
            ctxXZ.beginPath();
            ctxXZ.arc(toCanvasX(currentFrame.TCP1_X), toCanvasZ(currentFrame.TCP1_Z), 10, 0, Math.PI * 2);
            ctxXZ.fill();

            // TCP2 (íŒŒë‘)
            ctxXZ.fillStyle = '#2196f3';
            ctxXZ.beginPath();
            ctxXZ.arc(toCanvasX(currentFrame.TCP2_X), toCanvasZ(currentFrame.TCP2_Z), 10, 0, Math.PI * 2);
            ctxXZ.fill();

            // ì¶• ë¼ë²¨
            ctxXZ.fillStyle = '#333';
            ctxXZ.font = '14px Arial';
            ctxXZ.fillText('X â†’', width - 40, height - 10);
            ctxXZ.fillText('Z â†‘', 10, 20);
        }

        // YZ ì •ë©´ë„ ê·¸ë¦¬ê¸°
        function drawYZView(frames, currentIndex) {
            const width = canvasYZ.width;
            const height = canvasYZ.height;

            ctxYZ.clearRect(0, 0, width, height);

            // ë¡œë´‡ ë² ì´ìŠ¤ ë° T-barë¥¼ í¬í•¨í•œ ë²”ìœ„ ê³„ì‚°
            const allY = frames.flatMap(f => {
                const rAngle = f.Gantry_R * Math.PI / 180;
                const rFrameAngle = rAngle + Math.PI / 2;  // Rì¶• í”„ë ˆì„ ë°©í–¥
                const r1Y = f.Gantry_Y + 488 * Math.sin(rFrameAngle);
                const r2Y = f.Gantry_Y - 488 * Math.sin(rFrameAngle);
                return [f.Gantry_Y, f.TCP1_Y, f.TCP2_Y, r1Y, r2Y];
            });
            const allZ = frames.flatMap(f => [f.Gantry_Z, f.TCP1_Z, f.TCP2_Z, 0, 220]);
            const minY = Math.min(...allY) - 200;
            const maxY = Math.max(...allY) + 200;
            const minZ = Math.min(...allZ) - 50;
            const maxZ = Math.max(...allZ) + 100;

            const margin = 50;
            const scaleY = (width - 2 * margin) / (maxY - minY);
            const scaleZ = (height - 2 * margin) / (maxZ - minZ);
            const scale = Math.min(scaleY, scaleZ);

            function toCanvasY(y) {
                return margin + (y - minY) * scale;
            }

            function toCanvasZ(z) {
                return height - margin - (z - minZ) * scale;
            }

            // ê·¸ë¦¬ë“œ
            ctxYZ.strokeStyle = '#e0e0e0';
            ctxYZ.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = margin + (width - 2 * margin) * i / 10;
                const z = margin + (height - 2 * margin) * i / 10;
                ctxYZ.beginPath();
                ctxYZ.moveTo(y, margin);
                ctxYZ.lineTo(y, height - margin);
                ctxYZ.stroke();
                ctxYZ.beginPath();
                ctxYZ.moveTo(margin, z);
                ctxYZ.lineTo(width - margin, z);
                ctxYZ.stroke();
            }

            const currentFrame = frames[currentIndex];

            // Të°” í˜•ìƒ (ì •ë©´: í‰íŒ í•˜ë©´=Z0(ë°”ë‹¥), í‰íŒ ìƒë©´=Z20(ìš©ì ‘ì„ ), ì›¹=Z20~220)
            if (showTBar) {
                // Të°”ëŠ” ê³ ì • ìœ„ì¹˜ (ì²« í”„ë ˆì„ì—ì„œ ê°€ì ¸ì˜´)
                const tbarY = frames[0].TBar_Center_Y || 500;
                const tbarZ = frames[0].TBar_Center_Z || 0;  // ë°”ë‹¥ë©´

                // ì›¹ ë°©í–¥: ë¹„ì „ìœ¼ë¡œë¶€í„° ìë™ ê³„ì‚°ëœ ê°’ ì‚¬ìš©, ì—†ìœ¼ë©´ Rì¶•-90Â° ì‚¬ìš©
                let webAngle;
                if (frames[0].TBar_Web_Angle !== undefined) {
                    webAngle = frames[0].TBar_Web_Angle; // ìë™ ê³„ì‚°ëœ ì›¹ ê°ë„
                } else {
                    const rAngle = frames[0].Gantry_R * Math.PI / 180;
                    webAngle = rAngle - Math.PI / 2; // í´ë°±: Rì¶• - 90Â°
                }

                const plateWidth = 300;   // í‰íŒ í­ 300mm
                const plateThickness = 20;  // í‰íŒ ë‘ê»˜
                const webThickness = 12;  // ì›¹ ë‘ê»˜ 12mm
                const webLength = 1000;   // ì›¹ ê¸¸ì´ 1000mm
                const webHeight = 200;    // ì›¹ ë†’ì´ 200mm

                ctxYZ.fillStyle = 'rgba(121, 85, 72, 0.3)';
                ctxYZ.strokeStyle = '#795548';
                ctxYZ.lineWidth = 2;

                // YZ ì •ë©´ë„ì—ì„œ ì›¹ì˜ Y ë°©í–¥ íˆ¬ì˜: |sin(webAngle)| * webLength
                const projectedWidth = Math.abs(webLength * Math.sin(webAngle));
                const displayWidth = Math.max(projectedWidth, webThickness); // ìµœì†Œ 12mm
                console.log(`ğŸ” YZ ì •ë©´ë„ - webAngle: ${(webAngle * 180 / Math.PI).toFixed(1)}Â°, projectedWidth: ${projectedWidth.toFixed(1)}mm, displayWidth: ${displayWidth.toFixed(1)}mm`);

                // í‰íŒ (Z=0~20, ë°”ë‹¥ì— ë†“ì„, Yì¶• ì¤‘ì‹¬ Â±150mm)
                ctxYZ.fillRect(toCanvasY(tbarY - plateWidth/2), toCanvasZ(tbarZ + plateThickness),
                              plateWidth * scale, plateThickness * scale);
                ctxYZ.strokeRect(toCanvasY(tbarY - plateWidth/2), toCanvasZ(tbarZ + plateThickness),
                                plateWidth * scale, plateThickness * scale);

                // ì›¹ (Z=20~220, í‰íŒ ìƒë©´ì—ì„œ ìœ„ë¡œ, ê°ë„ì— ë”°ë¼ í­ì´ ë‹¬ë¼ì§)
                ctxYZ.fillRect(toCanvasY(tbarY - displayWidth/2), toCanvasZ(tbarZ + plateThickness + webHeight),
                              displayWidth * scale, webHeight * scale);
                ctxYZ.strokeRect(toCanvasY(tbarY - displayWidth/2), toCanvasZ(tbarZ + plateThickness + webHeight),
                                displayWidth * scale, webHeight * scale);
            }

            // Rì¶• ì¤‘ì‹¬
            ctxYZ.fillStyle = '#4caf50';
            ctxYZ.beginPath();
            ctxYZ.arc(toCanvasY(currentFrame.Gantry_Y), toCanvasZ(currentFrame.Gantry_Z), 8, 0, Math.PI * 2);
            ctxYZ.fill();

            // ë¡œë´‡ ë² ì´ìŠ¤ ìœ„ì¹˜ (Yì¶• íˆ¬ì˜)
            // Rì¶• í”„ë ˆì„ = Gantry_R + 90Â°
            const rAngle = currentFrame.Gantry_R * Math.PI / 180;
            const rFrameAngle = rAngle + Math.PI / 2;
            const robot1BaseY = currentFrame.Gantry_Y + 488 * Math.sin(rFrameAngle);
            const robot2BaseY = currentFrame.Gantry_Y - 488 * Math.sin(rFrameAngle);

            // ë°”ë”” í”„ë ˆì„ (ë‘ ë¡œë´‡ ì—°ê²°í•˜ëŠ” ë°”)
            ctxYZ.strokeStyle = '#ff6f00';
            ctxYZ.lineWidth = 8;
            ctxYZ.beginPath();
            ctxYZ.moveTo(toCanvasY(robot1BaseY), toCanvasZ(currentFrame.Gantry_Z));
            ctxYZ.lineTo(toCanvasY(robot2BaseY), toCanvasZ(currentFrame.Gantry_Z));
            ctxYZ.stroke();

            // ë¡œë´‡ ë² ì´ìŠ¤ (ì£¼í™©ìƒ‰ ì )
            ctxYZ.fillStyle = '#ff9800';
            ctxYZ.beginPath();
            ctxYZ.arc(toCanvasY(robot1BaseY), toCanvasZ(currentFrame.Gantry_Z), 6, 0, Math.PI * 2);
            ctxYZ.fill();
            ctxYZ.beginPath();
            ctxYZ.arc(toCanvasY(robot2BaseY), toCanvasZ(currentFrame.Gantry_Z), 6, 0, Math.PI * 2);
            ctxYZ.fill();

            // ë¡œë´‡ ë² ì´ìŠ¤ ë¼ë²¨
            ctxYZ.fillStyle = '#ff6f00';
            ctxYZ.font = 'bold 12px Arial';
            ctxYZ.fillText('R1', toCanvasY(robot1BaseY) + 10, toCanvasZ(currentFrame.Gantry_Z) - 10);
            ctxYZ.fillText('R2', toCanvasY(robot2BaseY) + 10, toCanvasZ(currentFrame.Gantry_Z) - 10);

            // ê²½ë¡œ ê·¸ë¦¬ê¸° (TCP1 - ë¹¨ê°•)
            ctxYZ.strokeStyle = '#f44336';
            ctxYZ.lineWidth = 2;
            ctxYZ.beginPath();
            for (let i = 0; i <= currentIndex; i++) {
                const y = toCanvasY(frames[i].TCP1_Y);
                const z = toCanvasZ(frames[i].TCP1_Z);
                if (i === 0) {
                    ctxYZ.moveTo(y, z);
                } else {
                    ctxYZ.lineTo(y, z);
                }
            }
            ctxYZ.stroke();

            // ê²½ë¡œ ê·¸ë¦¬ê¸° (TCP2 - íŒŒë‘)
            ctxYZ.strokeStyle = '#2196f3';
            ctxYZ.lineWidth = 2;
            ctxYZ.beginPath();
            for (let i = 0; i <= currentIndex; i++) {
                const y = toCanvasY(frames[i].TCP2_Y);
                const z = toCanvasZ(frames[i].TCP2_Z);
                if (i === 0) {
                    ctxYZ.moveTo(y, z);
                } else {
                    ctxYZ.lineTo(y, z);
                }
            }
            ctxYZ.stroke();

            // TCP1 (ë¹¨ê°•)
            ctxYZ.fillStyle = '#f44336';
            ctxYZ.beginPath();
            ctxYZ.arc(toCanvasY(currentFrame.TCP1_Y), toCanvasZ(currentFrame.TCP1_Z), 10, 0, Math.PI * 2);
            ctxYZ.fill();

            // TCP2 (íŒŒë‘)
            ctxYZ.fillStyle = '#2196f3';
            ctxYZ.beginPath();
            ctxYZ.arc(toCanvasY(currentFrame.TCP2_Y), toCanvasZ(currentFrame.TCP2_Z), 10, 0, Math.PI * 2);
            ctxYZ.fill();

            // ì¶• ë¼ë²¨
            ctxYZ.fillStyle = '#333';
            ctxYZ.font = '14px Arial';
            ctxYZ.fillText('Y â†’', width - 40, height - 10);
            ctxYZ.fillText('Z â†‘', 10, 20);
        }

        // ì´ˆê¸°í™”
        if (checkAuth()) {
            console.log('âœ… ì¸ì¦ ì™„ë£Œ');

            // ìƒ˜í”Œ ë°ì´í„° ìë™ ë¡œë“œ
            const sampleFiles = [
                'sample_data/welding_case1_basic.csv',
                'sample_data/welding_case2_robot_swap.csv',
                'sample_data/welding_case3_alternating.csv'
            ];

            // ë¡œì»¬ í…ŒìŠ¤íŠ¸ìš© ì•ˆë‚´
            console.log('ìƒ˜í”Œ íŒŒì¼ì„ ë“œë˜ê·¸ ì•¤ ë“œë¡­í•˜ê±°ë‚˜ "CSV ë¡œë“œ" ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”:');
            console.log('- welding_case1_basic.csv (ê¸°ë³¸ ìš©ì ‘)');
            console.log('- welding_case2_robot_swap.csv (ë¡œë´‡ ìŠ¤ì™‘)');
            console.log('- welding_case3_alternating.csv (êµì°¨ ìš©ì ‘)');
        }
    </script>
</body>
</html>
