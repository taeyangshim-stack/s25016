<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>용접선 교차 검증 - Weld Line Cross Check</title>
  <style>
    :root {
      --bg: #f5f7fa;
      --panel: #ffffff;
      --border: #e0e4eb;
      --text: #2c3e50;
      --muted: #7f8c9a;
      --accent: #3498db;
      --line1: #e74c3c;
      --line2: #27ae60;
      --pass: #27ae60;
      --fail: #e74c3c;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font: 14px/1.6 system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', sans-serif;
    }
    header {
      padding: 20px 24px;
      background: #fff;
      border-bottom: 1px solid var(--border);
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }
    h1 { margin: 0 0 4px; font-size: 20px; color: #2c3e50; }
    .subtitle { color: var(--muted); font-size: 13px; }
    main {
      padding: 20px;
      max-width: 1400px;
      margin: 0 auto;
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    }
    .panel h2 {
      margin: 0 0 16px;
      font-size: 15px;
      color: var(--accent);
      font-weight: 600;
    }

    /* 입력 섹션 */
    .input-section {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      align-items: flex-end;
    }
    .line-group {
      display: flex;
      gap: 16px;
      padding: 16px;
      background: #fafbfc;
      border: 1px solid var(--border);
      border-radius: 10px;
    }
    .line-group.line1 { border-left: 4px solid var(--line1); }
    .line-group.line2 { border-left: 4px solid var(--line2); }
    .point-box h4 {
      margin: 0 0 10px;
      font-size: 12px;
      color: var(--muted);
      font-weight: 500;
    }
    .coords-row {
      display: flex;
      gap: 8px;
    }
    .coord-input {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .coord-input span {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
      font-weight: 500;
    }
    .coord-input input {
      width: 80px;
      padding: 10px 8px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: #fff;
      color: var(--text);
      font-size: 14px;
      text-align: center;
    }
    .coord-input input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
    }
    .btn-group {
      display: flex;
      gap: 10px;
      margin-left: auto;
    }
    button {
      padding: 12px 20px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #fff;
      color: var(--text);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }
    button:hover {
      background: #f8f9fa;
      border-color: var(--accent);
    }
    button.primary {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
      font-weight: 600;
    }
    button.primary:hover {
      background: #2980b9;
    }

    /* 메인 영역 */
    .main-area {
      display: grid;
      grid-template-columns: 220px 1fr;
      gap: 20px;
      min-height: 500px;
    }
    @media (max-width: 900px) {
      .main-area { grid-template-columns: 1fr; }
      .input-section { flex-direction: column; }
      .btn-group { margin-left: 0; margin-top: 16px; width: 100%; }
      .btn-group button { flex: 1; }
    }

    /* 결과 */
    .result-panel { display: flex; flex-direction: column; }
    .result-box {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 24px;
      border-radius: 12px;
    }
    .result-box.pass {
      background: linear-gradient(135deg, #d4efdf 0%, #a9dfbf 100%);
      border: 2px solid var(--pass);
    }
    .result-box.fail {
      background: linear-gradient(135deg, #fadbd8 0%, #f5b7b1 100%);
      border: 2px solid var(--fail);
    }
    .result-box.waiting {
      background: #f8f9fa;
      border: 2px dashed var(--border);
    }
    .result-icon { font-size: 56px; margin-bottom: 12px; }
    .result-text { font-size: 28px; font-weight: 700; }
    .result-box.pass .result-text { color: var(--pass); }
    .result-box.fail .result-text { color: var(--fail); }
    .result-box.waiting .result-text { color: var(--muted); font-size: 20px; }
    .result-detail { margin-top: 8px; font-size: 14px; color: var(--muted); }

    /* 그래프 */
    .graph-panel { display: flex; flex-direction: column; }
    .canvas-wrap {
      flex: 1;
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 10px;
      position: relative;
      min-height: 450px;
    }
    canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
    }
    .legend {
      position: absolute;
      top: 16px;
      right: 16px;
      background: rgba(255,255,255,0.95);
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 13px;
      border: 1px solid var(--border);
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 6px 0;
    }
    .legend-line {
      width: 24px;
      height: 4px;
      border-radius: 2px;
    }

    /* 코드 */
    .code-section { margin-top: 20px; }
    .code-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .code-tabs { display: flex; gap: 6px; }
    .code-tab {
      padding: 6px 14px;
      background: #f8f9fa;
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--muted);
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
    }
    .code-tab.active {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }
    pre {
      background: #f8f9fa;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 20px;
      overflow-x: auto;
      font-size: 13px;
      line-height: 1.6;
      margin: 0;
      max-height: 350px;
    }
    code { font-family: 'Consolas', 'Monaco', monospace; }
    .keyword { color: #8e44ad; }
    .type { color: #2980b9; }
    .number { color: #e67e22; }
    .comment { color: #7f8c8d; }
    .method { color: #16a085; }
  </style>
</head>
<body>
  <header>
    <h1>용접선 교차 검증</h1>
    <div class="subtitle">Weld Line Cross Check · XY 평면 투영 기반 선분 교차 검사</div>
  </header>

  <main>
    <!-- 입력 섹션 -->
    <div class="panel">
      <h2>좌표 입력 (3D → XY 평면 투영)</h2>
      <div class="input-section">
        <div class="line-group line1">
          <div class="point-box">
            <h4>용접선 1 - 시작점</h4>
            <div class="coords-row">
              <div class="coord-input"><span>X</span><input type="number" id="s1x" value="0"></div>
              <div class="coord-input"><span>Y</span><input type="number" id="s1y" value="0"></div>
              <div class="coord-input"><span>Z</span><input type="number" id="s1z" value="0"></div>
            </div>
          </div>
          <div class="point-box">
            <h4>용접선 1 - 끝점</h4>
            <div class="coords-row">
              <div class="coord-input"><span>X</span><input type="number" id="e1x" value="100"></div>
              <div class="coord-input"><span>Y</span><input type="number" id="e1y" value="100"></div>
              <div class="coord-input"><span>Z</span><input type="number" id="e1z" value="0"></div>
            </div>
          </div>
        </div>
        <div class="line-group line2">
          <div class="point-box">
            <h4>용접선 2 - 시작점</h4>
            <div class="coords-row">
              <div class="coord-input"><span>X</span><input type="number" id="s2x" value="0"></div>
              <div class="coord-input"><span>Y</span><input type="number" id="s2y" value="100"></div>
              <div class="coord-input"><span>Z</span><input type="number" id="s2z" value="0"></div>
            </div>
          </div>
          <div class="point-box">
            <h4>용접선 2 - 끝점</h4>
            <div class="coords-row">
              <div class="coord-input"><span>X</span><input type="number" id="e2x" value="100"></div>
              <div class="coord-input"><span>Y</span><input type="number" id="e2y" value="0"></div>
              <div class="coord-input"><span>Z</span><input type="number" id="e2z" value="0"></div>
            </div>
          </div>
        </div>
        <div class="btn-group">
          <button onclick="loadSample1()">샘플1 (교차)</button>
          <button onclick="loadSample2()">샘플2 (평행)</button>
          <button class="primary" onclick="checkIntersection()">검사 실행</button>
        </div>
      </div>
    </div>

    <!-- 메인 영역 -->
    <div class="main-area">
      <div class="result-panel panel">
        <h2>검사 결과</h2>
        <div id="result" class="result-box waiting">
          <div class="result-icon">⏳</div>
          <div class="result-text">대기 중</div>
          <div class="result-detail">검사 실행 버튼을 클릭하세요</div>
        </div>
      </div>

      <div class="graph-panel panel">
        <h2>XY 평면 투영 그래프</h2>
        <div class="canvas-wrap">
          <canvas id="canvas"></canvas>
          <div class="legend">
            <div class="legend-item">
              <div class="legend-line" style="background: var(--line1);"></div>
              <span>용접선 1</span>
            </div>
            <div class="legend-item">
              <div class="legend-line" style="background: var(--line2);"></div>
              <span>용접선 2</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- C# 코드 -->
    <div class="panel code-section">
      <div class="code-header">
        <h2>C# 교차 검증 알고리즘</h2>
        <div class="code-tabs">
          <div class="code-tab active" onclick="showCode('full')">전체</div>
          <div class="code-tab" onclick="showCode('core')">핵심</div>
        </div>
      </div>
      <pre><code id="code-content"></code></pre>
    </div>
  </main>

  <script>
    // C# Code
    const csharpCodeFull = `<span class="keyword">using</span> System;

<span class="keyword">namespace</span> WeldLineCheck
{
    <span class="keyword">public class</span> <span class="type">WeldLineCrossChecker</span>
    {
        <span class="keyword">public struct</span> <span class="type">Point2D</span>
        {
            <span class="keyword">public double</span> X, Y;
            <span class="keyword">public</span> <span class="method">Point2D</span>(<span class="keyword">double</span> x, <span class="keyword">double</span> y) { X = x; Y = y; }
        }

        <span class="comment">// 3D → XY 평면 투영</span>
        <span class="keyword">public static</span> <span class="type">Point2D</span> <span class="method">ProjectToXY</span>(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> z)
            => <span class="keyword">new</span> <span class="type">Point2D</span>(x, y);

        <span class="comment">// CCW (Counter-Clockwise) 방향 판별</span>
        <span class="keyword">private static double</span> <span class="method">CCW</span>(<span class="type">Point2D</span> a, <span class="type">Point2D</span> b, <span class="type">Point2D</span> c)
            => (b.X - a.X) * (c.Y - a.Y) - (b.Y - a.Y) * (c.X - a.X);

        <span class="comment">// 선분 교차 검사</span>
        <span class="keyword">public static bool</span> <span class="method">DoLinesIntersect</span>(<span class="type">Point2D</span> p1, <span class="type">Point2D</span> p2, <span class="type">Point2D</span> p3, <span class="type">Point2D</span> p4)
        {
            <span class="keyword">double</span> d1 = <span class="method">CCW</span>(p3, p4, p1);
            <span class="keyword">double</span> d2 = <span class="method">CCW</span>(p3, p4, p2);
            <span class="keyword">double</span> d3 = <span class="method">CCW</span>(p1, p2, p3);
            <span class="keyword">double</span> d4 = <span class="method">CCW</span>(p1, p2, p4);

            <span class="keyword">if</span> (((d1 > <span class="number">0</span> && d2 < <span class="number">0</span>) || (d1 < <span class="number">0</span> && d2 > <span class="number">0</span>)) &&
                ((d3 > <span class="number">0</span> && d4 < <span class="number">0</span>) || (d3 < <span class="number">0</span> && d4 > <span class="number">0</span>)))
                <span class="keyword">return true</span>;

            <span class="keyword">return false</span>;
        }

        <span class="comment">// 메인 검사 함수</span>
        <span class="keyword">public static bool</span> <span class="method">CheckWeldLineCross</span>(
            <span class="keyword">double</span> s1x, <span class="keyword">double</span> s1y, <span class="keyword">double</span> s1z,
            <span class="keyword">double</span> e1x, <span class="keyword">double</span> e1y, <span class="keyword">double</span> e1z,
            <span class="keyword">double</span> s2x, <span class="keyword">double</span> s2y, <span class="keyword">double</span> s2z,
            <span class="keyword">double</span> e2x, <span class="keyword">double</span> e2y, <span class="keyword">double</span> e2z)
        {
            <span class="keyword">var</span> start1 = <span class="method">ProjectToXY</span>(s1x, s1y, s1z);
            <span class="keyword">var</span> end1   = <span class="method">ProjectToXY</span>(e1x, e1y, e1z);
            <span class="keyword">var</span> start2 = <span class="method">ProjectToXY</span>(s2x, s2y, s2z);
            <span class="keyword">var</span> end2   = <span class="method">ProjectToXY</span>(e2x, e2y, e2z);
            <span class="keyword">return</span> <span class="method">DoLinesIntersect</span>(start1, end1, start2, end2);
        }
    }
}`;

    const csharpCodeCore = `<span class="comment">// CCW (Counter-Clockwise) 방향 판별</span>
<span class="keyword">private static double</span> <span class="method">CCW</span>(<span class="type">Point2D</span> a, <span class="type">Point2D</span> b, <span class="type">Point2D</span> c)
    => (b.X - a.X) * (c.Y - a.Y) - (b.Y - a.Y) * (c.X - a.X);

<span class="comment">// 선분 교차 검사</span>
<span class="keyword">public static bool</span> <span class="method">DoLinesIntersect</span>(<span class="type">Point2D</span> p1, <span class="type">Point2D</span> p2, <span class="type">Point2D</span> p3, <span class="type">Point2D</span> p4)
{
    <span class="keyword">double</span> d1 = <span class="method">CCW</span>(p3, p4, p1);
    <span class="keyword">double</span> d2 = <span class="method">CCW</span>(p3, p4, p2);
    <span class="keyword">double</span> d3 = <span class="method">CCW</span>(p1, p2, p3);
    <span class="keyword">double</span> d4 = <span class="method">CCW</span>(p1, p2, p4);

    <span class="comment">// 서로 다른 방향에 있으면 교차</span>
    <span class="keyword">if</span> (((d1 > <span class="number">0</span> && d2 < <span class="number">0</span>) || (d1 < <span class="number">0</span> && d2 > <span class="number">0</span>)) &&
        ((d3 > <span class="number">0</span> && d4 < <span class="number">0</span>) || (d3 < <span class="number">0</span> && d4 > <span class="number">0</span>)))
        <span class="keyword">return true</span>;

    <span class="keyword">return false</span>;
}`;

    // Algorithm
    function ccw(ax, ay, bx, by, cx, cy) {
      return (bx - ax) * (cy - ay) - (by - ay) * (cx - ax);
    }

    function doLinesIntersect(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
      const d1 = ccw(p3x, p3y, p4x, p4y, p1x, p1y);
      const d2 = ccw(p3x, p3y, p4x, p4y, p2x, p2y);
      const d3 = ccw(p1x, p1y, p2x, p2y, p3x, p3y);
      const d4 = ccw(p1x, p1y, p2x, p2y, p4x, p4y);

      if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&
          ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {
        return true;
      }
      return false;
    }

    // UI
    function getInputValues() {
      return {
        s1x: parseFloat(document.getElementById('s1x').value) || 0,
        s1y: parseFloat(document.getElementById('s1y').value) || 0,
        s1z: parseFloat(document.getElementById('s1z').value) || 0,
        e1x: parseFloat(document.getElementById('e1x').value) || 0,
        e1y: parseFloat(document.getElementById('e1y').value) || 0,
        e1z: parseFloat(document.getElementById('e1z').value) || 0,
        s2x: parseFloat(document.getElementById('s2x').value) || 0,
        s2y: parseFloat(document.getElementById('s2y').value) || 0,
        s2z: parseFloat(document.getElementById('s2z').value) || 0,
        e2x: parseFloat(document.getElementById('e2x').value) || 0,
        e2y: parseFloat(document.getElementById('e2y').value) || 0,
        e2z: parseFloat(document.getElementById('e2z').value) || 0
      };
    }

    function setInputValues(vals) {
      for (const [key, val] of Object.entries(vals)) {
        document.getElementById(key).value = val;
      }
    }

    function loadSample1() {
      setInputValues({
        s1x: 0, s1y: 0, s1z: 0,
        e1x: 100, e1y: 100, e1z: 0,
        s2x: 0, s2y: 100, s2z: 0,
        e2x: 100, e2y: 0, e2z: 0
      });
      checkIntersection();
    }

    function loadSample2() {
      setInputValues({
        s1x: 0, s1y: 0, s1z: 0,
        e1x: 100, e1y: 0, e1z: 0,
        s2x: 0, s2y: 50, s2z: 0,
        e2x: 100, e2y: 50, e2z: 0
      });
      checkIntersection();
    }

    function checkIntersection() {
      const v = getInputValues();
      const intersects = doLinesIntersect(
        v.s1x, v.s1y, v.e1x, v.e1y,
        v.s2x, v.s2y, v.e2x, v.e2y
      );

      const resultBox = document.getElementById('result');
      if (intersects) {
        resultBox.className = 'result-box fail';
        resultBox.innerHTML = `
          <div class="result-icon">❌</div>
          <div class="result-text">FAIL</div>
          <div class="result-detail">교차 발생</div>
        `;
      } else {
        resultBox.className = 'result-box pass';
        resultBox.innerHTML = `
          <div class="result-icon">✅</div>
          <div class="result-text">PASS</div>
          <div class="result-detail">교차 없음</div>
        `;
      }

      drawCanvas(v, intersects);
    }

    function drawCanvas(v, intersects) {
      const canvas = document.getElementById('canvas');
      const wrap = canvas.parentElement;
      const rect = wrap.getBoundingClientRect();

      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;

      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);

      const width = rect.width;
      const height = rect.height;
      const padding = 70;

      // Clear - light background
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, width, height);

      // Bounds
      const allX = [v.s1x, v.e1x, v.s2x, v.e2x];
      const allY = [v.s1y, v.e1y, v.s2y, v.e2y];
      let minX = Math.min(...allX);
      let maxX = Math.max(...allX);
      let minY = Math.min(...allY);
      let maxY = Math.max(...allY);

      const rangeX = (maxX - minX) || 100;
      const rangeY = (maxY - minY) || 100;
      minX -= rangeX * 0.15;
      maxX += rangeX * 0.15;
      minY -= rangeY * 0.15;
      maxY += rangeY * 0.15;

      const scaleX = (width - 2 * padding) / (maxX - minX);
      const scaleY = (height - 2 * padding) / (maxY - minY);
      const scale = Math.min(scaleX, scaleY);

      const offsetX = (width - (maxX - minX) * scale) / 2;
      const offsetY = (height - (maxY - minY) * scale) / 2;

      const toX = (x) => offsetX + (x - minX) * scale;
      const toY = (y) => height - offsetY - (y - minY) * scale;

      // Grid
      ctx.strokeStyle = '#e8ecef';
      ctx.lineWidth = 1;
      const gridStep = Math.pow(10, Math.floor(Math.log10(Math.max(rangeX, rangeY) / 4)));

      ctx.font = '12px system-ui';
      ctx.fillStyle = '#95a5a6';

      for (let x = Math.ceil(minX / gridStep) * gridStep; x <= maxX; x += gridStep) {
        ctx.beginPath();
        ctx.moveTo(toX(x), padding - 20);
        ctx.lineTo(toX(x), height - padding + 20);
        ctx.stroke();
        ctx.fillText(x.toFixed(0), toX(x) - 12, height - padding + 38);
      }
      for (let y = Math.ceil(minY / gridStep) * gridStep; y <= maxY; y += gridStep) {
        ctx.beginPath();
        ctx.moveTo(padding - 20, toY(y));
        ctx.lineTo(width - padding + 20, toY(y));
        ctx.stroke();
        ctx.fillText(y.toFixed(0), padding - 45, toY(y) + 5);
      }

      // Axes
      ctx.strokeStyle = '#bdc3c7';
      ctx.lineWidth = 2;
      if (minY <= 0 && maxY >= 0) {
        ctx.beginPath();
        ctx.moveTo(padding - 20, toY(0));
        ctx.lineTo(width - padding + 20, toY(0));
        ctx.stroke();
      }
      if (minX <= 0 && maxX >= 0) {
        ctx.beginPath();
        ctx.moveTo(toX(0), padding - 20);
        ctx.lineTo(toX(0), height - padding + 20);
        ctx.stroke();
      }

      // Line 1 (red)
      ctx.strokeStyle = '#e74c3c';
      ctx.lineWidth = 5;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(toX(v.s1x), toY(v.s1y));
      ctx.lineTo(toX(v.e1x), toY(v.e1y));
      ctx.stroke();

      // Line 2 (green)
      ctx.strokeStyle = '#27ae60';
      ctx.beginPath();
      ctx.moveTo(toX(v.s2x), toY(v.s2y));
      ctx.lineTo(toX(v.e2x), toY(v.e2y));
      ctx.stroke();

      // Points
      const drawPoint = (x, y, color, label) => {
        // White outline
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(toX(x), toY(y), 10, 0, Math.PI * 2);
        ctx.fill();

        // Colored fill
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(toX(x), toY(y), 8, 0, Math.PI * 2);
        ctx.fill();

        // Label background
        ctx.font = 'bold 12px system-ui';
        const tw = ctx.measureText(label).width;
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.fillRect(toX(x) + 12, toY(y) - 22, tw + 10, 20);

        // Label
        ctx.fillStyle = '#2c3e50';
        ctx.fillText(label, toX(x) + 17, toY(y) - 7);
      };

      drawPoint(v.s1x, v.s1y, '#e74c3c', `S1(${v.s1x}, ${v.s1y})`);
      drawPoint(v.e1x, v.e1y, '#e74c3c', `E1(${v.e1x}, ${v.e1y})`);
      drawPoint(v.s2x, v.s2y, '#27ae60', `S2(${v.s2x}, ${v.s2y})`);
      drawPoint(v.e2x, v.e2y, '#27ae60', `E2(${v.e2x}, ${v.e2y})`);

      // Intersection
      if (intersects) {
        const denom = (v.s1x - v.e1x) * (v.s2y - v.e2y) - (v.s1y - v.e1y) * (v.s2x - v.e2x);
        if (Math.abs(denom) > 0.0001) {
          const t = ((v.s1x - v.s2x) * (v.s2y - v.e2y) - (v.s1y - v.s2y) * (v.s2x - v.e2x)) / denom;
          const ix = v.s1x + t * (v.e1x - v.s1x);
          const iy = v.s1y + t * (v.e1y - v.s1y);

          // Red X mark
          ctx.strokeStyle = '#c0392b';
          ctx.lineWidth = 4;
          const size = 18;
          ctx.beginPath();
          ctx.moveTo(toX(ix) - size, toY(iy) - size);
          ctx.lineTo(toX(ix) + size, toY(iy) + size);
          ctx.moveTo(toX(ix) + size, toY(iy) - size);
          ctx.lineTo(toX(ix) - size, toY(iy) + size);
          ctx.stroke();

          // Circle
          ctx.beginPath();
          ctx.arc(toX(ix), toY(iy), size + 6, 0, Math.PI * 2);
          ctx.stroke();

          // Label
          const label = `교차점 (${ix.toFixed(1)}, ${iy.toFixed(1)})`;
          ctx.font = 'bold 14px system-ui';
          const tw = ctx.measureText(label).width;
          ctx.fillStyle = '#c0392b';
          ctx.fillRect(toX(ix) + 30, toY(iy) - 28, tw + 20, 32);
          ctx.fillStyle = '#fff';
          ctx.fillText(label, toX(ix) + 40, toY(iy) - 6);
        }
      }

      // Axis labels
      ctx.fillStyle = '#7f8c8d';
      ctx.font = 'bold 14px system-ui';
      ctx.fillText('X', width - padding + 15, toY(0) - 8);
      ctx.fillText('Y', toX(0) + 10, padding - 25);
    }

    function showCode(type) {
      document.querySelectorAll('.code-tab').forEach(t => t.classList.remove('active'));
      event.target.classList.add('active');
      document.getElementById('code-content').innerHTML = type === 'full' ? csharpCodeFull : csharpCodeCore;
    }

    // Init
    document.addEventListener('DOMContentLoaded', () => {
      showCode('full');
      drawCanvas(getInputValues(), false);
    });

    window.addEventListener('resize', () => {
      drawCanvas(getInputValues(), document.querySelector('.result-box').classList.contains('fail'));
    });
  </script>
</body>
</html>
